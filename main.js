/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvaslmsHelperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian14 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  canvasUrl: "",
  canvasToken: ""
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Canvas LMS settings" });
    containerEl.createEl("p", {
      text: "To use this plugin, you need a Canvas API token. Generate one from your Canvas account settings > Approved Integrations > New Access Token."
    });
    new import_obsidian.Setting(containerEl).setName("Canvas URL").setDesc("The base URL of your Canvas instance (e.g., https://your-institution.instructure.com)").addText((text) => text.setPlaceholder("https://your-institution.instructure.com").setValue(this.plugin.settings.canvasUrl).onChange(async (value) => {
      this.plugin.settings.canvasUrl = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Canvas API token").setDesc("Your Canvas API access token").addText((text) => {
      text.setPlaceholder("Enter your Canvas API token").setValue(this.plugin.settings.canvasToken).onChange(async (value) => {
        this.plugin.settings.canvasToken = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
  }
};

// src/canvas/api-client.ts
var import_obsidian2 = require("obsidian");
var CanvasApiClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.token = token;
  }
  /**
   * Make a generic API request to Canvas
   */
  async request(endpoint) {
    var _a;
    const url = `${this.baseUrl}${endpoint}`;
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.token}`,
          "Accept": "application/json"
        }
      });
      if (response.status === 200) {
        return response.json;
      } else {
        throw new Error(`HTTP ${response.status}: ${response.text}`);
      }
    } catch (error) {
      if (error.status === 401) {
        throw new Error("Invalid Canvas token. Please check your settings.");
      } else if (error.status === 403) {
        throw new Error("Access denied. You may not have permission to view this course.");
      } else if (error.status === 404) {
        throw new Error("Course/resource not found. Check the course ID.");
      } else if ((_a = error.message) == null ? void 0 : _a.includes("net::")) {
        throw new Error("Cannot connect to Canvas. Check your internet connection.");
      } else {
        throw error;
      }
    }
  }
  /**
   * Make a paginated API request to Canvas, fetching all pages
   */
  async requestPaginated(endpoint) {
    var _a;
    const results = [];
    let url = `${this.baseUrl}${endpoint}${endpoint.includes("?") ? "&" : "?"}per_page=100`;
    while (url) {
      try {
        const response = await (0, import_obsidian2.requestUrl)({
          url,
          method: "GET",
          headers: {
            "Authorization": `Bearer ${this.token}`,
            "Accept": "application/json"
          }
        });
        if (response.status === 200) {
          const data = response.json;
          results.push(...data);
          url = this.getNextPageUrl(response.headers);
        } else {
          throw new Error(`HTTP ${response.status}: ${response.text}`);
        }
      } catch (error) {
        if (error.status === 401) {
          throw new Error("Invalid Canvas token. Please check your settings.");
        } else if (error.status === 403) {
          throw new Error("Access denied. You may not have permission to view this course.");
        } else if (error.status === 404) {
          throw new Error("Course/resource not found. Check the course ID.");
        } else if ((_a = error.message) == null ? void 0 : _a.includes("net::")) {
          throw new Error("Cannot connect to Canvas. Check your internet connection.");
        } else {
          throw error;
        }
      }
    }
    return results;
  }
  /**
   * Parse the Link header to find the next page URL
   */
  getNextPageUrl(headers) {
    const linkHeader = headers["link"] || headers["Link"];
    if (!linkHeader) return null;
    const links = linkHeader.split(",");
    for (const link of links) {
      const match = link.match(/<([^>]+)>;\s*rel="next"/);
      if (match) {
        return match[1];
      }
    }
    return null;
  }
  /**
   * Get course information
   */
  async getCourse(courseId) {
    return await this.request(`/api/v1/courses/${courseId}`);
  }
  /**
   * Get all modules in a course (handles pagination)
   */
  async getModules(courseId) {
    return await this.requestPaginated(`/api/v1/courses/${courseId}/modules`);
  }
  /**
   * Get all items in a module (handles pagination)
   */
  async getModuleItems(courseId, moduleId) {
    return await this.requestPaginated(
      `/api/v1/courses/${courseId}/modules/${moduleId}/items`
    );
  }
  /**
   * Get a specific page by URL slug
   */
  async getPage(courseId, pageUrl) {
    return await this.request(
      `/api/v1/courses/${courseId}/pages/${pageUrl}`
    );
  }
  /**
   * Get a specific assignment
   */
  async getAssignment(courseId, assignmentId) {
    return await this.request(
      `/api/v1/courses/${courseId}/assignments/${assignmentId}`
    );
  }
  /**
   * Get a specific discussion topic
   */
  async getDiscussion(courseId, topicId) {
    return await this.request(
      `/api/v1/courses/${courseId}/discussion_topics/${topicId}`
    );
  }
  /**
   * Get a specific file
   */
  async getFile(fileId) {
    return await this.request(`/api/v1/files/${fileId}`);
  }
  /**
   * Get all folders in a course (includes all subfolders as a flat list)
   */
  async getCourseFolders(courseId) {
    return await this.requestPaginated(`/api/v1/courses/${courseId}/folders`);
  }
  /**
   * Get all files in a folder
   */
  async getFolderFiles(folderId) {
    return await this.requestPaginated(`/api/v1/folders/${folderId}/files`);
  }
};

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules) this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options)) return rule;
    if (rule = findRule(this._keep, node, this.options)) return rule;
    if (rule = findRule(this._remove, node, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options)) return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService)) return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// src/utils/html-to-markdown.ts
var turndownService = new turndown_browser_es_default({
  headingStyle: "atx",
  hr: "---",
  bulletListMarker: "-",
  codeBlockStyle: "fenced",
  emDelimiter: "*"
});
turndownService.addRule("removeCanvasWrappers", {
  filter: (node) => {
    var _a, _b;
    return node.nodeName === "DIV" && ((_b = (_a = node.getAttribute("class")) == null ? void 0 : _a.includes("user_content")) != null ? _b : false);
  },
  replacement: (content) => content
});
function htmlToMarkdown(html) {
  if (!html) return "";
  try {
    return turndownService.turndown(html).trim();
  } catch (error) {
    console.error("Error converting HTML to Markdown:", error);
    return html.replace(/<[^>]+>/g, "").trim();
  }
}
function shiftHeadingLevels(markdown, shift) {
  const prefix = "#".repeat(shift);
  return markdown.replace(/^(#{1,6})\s/gm, `${prefix}$1 `);
}
function htmlToMarkdownNested(html) {
  const markdown = htmlToMarkdown(html);
  return shiftHeadingLevels(markdown, 2);
}

// src/canvas/formatter.ts
var CanvasCourseFormatter = class {
  /**
   * Format complete course data into Markdown
   */
  formatCourse(courseId, canvasUrl, modules, itemsData) {
    let markdown = "";
    markdown += this.formatFrontmatter(courseId, canvasUrl);
    markdown += "\n";
    for (const module2 of modules) {
      markdown += this.formatModule(module2, itemsData);
    }
    markdown += this.formatCourseFiles(modules, itemsData);
    return markdown;
  }
  /**
   * Format YAML frontmatter
   */
  formatFrontmatter(courseId, canvasUrl) {
    return `---
canvas_course_id: ${courseId}
canvas_url: ${canvasUrl}/courses/${courseId}
---`;
  }
  /**
   * Format a module and its items
   */
  formatModule(module2, itemsData) {
    let markdown = `
# ${module2.name}
`;
    markdown += `<!-- canvas_module_id: ${module2.id} -->
`;
    const items = itemsData.get(`module_${module2.id}`);
    if (items && items.length > 0) {
      for (const item of items) {
        markdown += this.formatModuleItem(item, itemsData);
      }
    }
    return markdown;
  }
  /**
   * Format a module item based on its type
   */
  formatModuleItem(item, itemsData) {
    switch (item.type) {
      case "SubHeader":
        return this.formatHeader(item);
      case "Page":
        return this.formatPage(item, itemsData);
      case "ExternalUrl":
        return this.formatLink(item);
      case "File":
        return this.formatFile(item, itemsData);
      case "Assignment":
        return this.formatAssignment(item, itemsData);
      case "Discussion":
        return this.formatDiscussion(item, itemsData);
      default:
        console.warn(`Unknown module item type: ${item.type}`);
        return "";
    }
  }
  /**
   * Format a header (SubHeader in Canvas)
   */
  formatHeader(item) {
    return `
## [header] ${item.title}
<!-- canvas_module_item_id: ${item.id} -->
`;
  }
  /**
   * Format a page
   */
  formatPage(item, itemsData) {
    const page = itemsData.get(`page_${item.page_url}`);
    let markdown = `
## [page] ${item.title}
`;
    if (page) {
      markdown += `<!-- canvas_page_id: ${page.url} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (page == null ? void 0 : page.body) {
      const bodyMarkdown = htmlToMarkdownNested(page.body);
      if (bodyMarkdown) {
        markdown += bodyMarkdown + "\n";
      }
    }
    return markdown;
  }
  /**
   * Format an external link
   */
  formatLink(item) {
    return `
## [link] ${item.title}
<!-- canvas_module_item_id: ${item.id} -->
url: ${item.external_url || ""}
`;
  }
  /**
   * Format a file
   */
  formatFile(item, itemsData) {
    const file = itemsData.get(`file_${item.content_id}`);
    let markdown = `
## [file] ${item.title}
`;
    if (file) {
      markdown += `<!-- canvas_file_id: ${file.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (file == null ? void 0 : file.filename) {
      markdown += `filename: ${file.filename}
`;
    }
    return markdown;
  }
  /**
   * Format an assignment
   */
  formatAssignment(item, itemsData) {
    const assignment = itemsData.get(`assignment_${item.content_id}`);
    let markdown = `
## [assignment] ${item.title}
`;
    if (assignment) {
      markdown += `<!-- canvas_assignment_id: ${assignment.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (assignment) {
      if (assignment.points_possible !== null && assignment.points_possible !== void 0) {
        markdown += `points: ${assignment.points_possible}
`;
      }
      if (assignment.due_at) {
        const dueDate = this.formatDate(assignment.due_at);
        markdown += `due: ${dueDate}
`;
      }
      if (assignment.grading_type) {
        markdown += `grade_display: ${assignment.grading_type}
`;
      }
      if (assignment.submission_types && assignment.submission_types.length > 0) {
        markdown += `submission_types: ${assignment.submission_types.join(", ")}
`;
      }
      if (assignment.description) {
        markdown += "\n---\n";
        const descriptionMarkdown = htmlToMarkdownNested(assignment.description);
        if (descriptionMarkdown) {
          markdown += descriptionMarkdown + "\n";
        }
      }
    }
    return markdown;
  }
  /**
   * Format a discussion
   */
  formatDiscussion(item, itemsData) {
    const discussion = itemsData.get(`discussion_${item.content_id}`);
    let markdown = `
## [discussion] ${item.title}
`;
    if (discussion) {
      markdown += `<!-- canvas_discussion_id: ${discussion.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (discussion) {
      markdown += `require_initial_post: ${discussion.require_initial_post}
`;
      markdown += `threaded: ${discussion.discussion_type === "threaded"}
`;
      const isGraded = discussion.assignment !== void 0;
      markdown += `graded: ${isGraded}
`;
      if (isGraded && discussion.assignment) {
        markdown += `points: ${discussion.assignment.points_possible}
`;
        if (discussion.assignment.due_at) {
          const dueDate = this.formatDate(discussion.assignment.due_at);
          markdown += `due: ${dueDate}
`;
        }
      }
      if (discussion.message) {
        markdown += "\n---\n";
        const messageMarkdown = htmlToMarkdownNested(discussion.message);
        if (messageMarkdown) {
          markdown += messageMarkdown + "\n";
        }
      }
    }
    return markdown;
  }
  /**
   * Format ISO date to "2026-01-20 02:00pm" format
   */
  formatDate(isoDate) {
    const date = new Date(isoDate);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    let hours = date.getHours();
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const ampm = hours >= 12 ? "pm" : "am";
    hours = hours % 12 || 12;
    return `${year}-${month}-${day} ${String(hours).padStart(2, "0")}:${minutes}${ampm}`;
  }
  /**
   * Format files not in any module
   */
  formatCourseFiles(modules, itemsData) {
    const courseFiles = itemsData.get("course_files");
    if (!courseFiles || courseFiles.length === 0) {
      return "";
    }
    const moduleFileIds = /* @__PURE__ */ new Set();
    for (const module2 of modules) {
      const items = itemsData.get(`module_${module2.id}`);
      if (items) {
        for (const item of items) {
          if (item.type === "File" && item.content_id) {
            moduleFileIds.add(item.content_id);
          }
        }
      }
    }
    const unmatchedFiles = courseFiles.filter((file) => !moduleFileIds.has(file.id));
    if (unmatchedFiles.length === 0) {
      return "";
    }
    let markdown = "\n\n---\n\n# Course Files\n\n";
    markdown += "<!-- Files uploaded to Canvas but not added to any module -->\n\n";
    for (const file of unmatchedFiles) {
      markdown += `## [file] ${file.display_name}
`;
      markdown += `<!-- canvas_file_id: ${file.id} -->
`;
      markdown += `filename: ${file.filename}

`;
    }
    return markdown;
  }
};

// src/modals/course-input-modal.ts
var import_obsidian3 = require("obsidian");
var CourseInputModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.courseId = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Download Canvas course");
    contentEl.createEl("p", {
      text: "Enter the Canvas course ID (number from course URL)"
    });
    contentEl.createEl("p", {
      text: "Example: 126998",
      cls: "mod-muted"
    });
    const inputSetting = new import_obsidian3.Setting(contentEl).setName("Course ID").addText((text) => {
      text.setPlaceholder("Enter course ID").onChange((value) => {
        this.courseId = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submit();
        }
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Download",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  submit() {
    if (!this.courseId) {
      const existingError = this.contentEl.querySelector(".course-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please enter a course ID",
        cls: "course-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    if (!/^\d+$/.test(this.courseId)) {
      const existingError = this.contentEl.querySelector(".course-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Course ID must be a number",
        cls: "course-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.courseId);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/simple-text-modal.ts
var import_obsidian4 = require("obsidian");
var SimpleTextModal = class extends import_obsidian4.Modal {
  constructor(app, title, label, placeholder, onSubmit) {
    super(app);
    this.value = "";
    this.title = title;
    this.label = label;
    this.placeholder = placeholder;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText(this.title);
    new import_obsidian4.Setting(contentEl).setName(this.label).addText((text) => {
      text.setPlaceholder(this.placeholder).onChange((value) => {
        this.value = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submit();
        }
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  submit() {
    if (!this.value) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: `Please enter a ${this.label.toLowerCase()}`,
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.value);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/two-field-modal.ts
var import_obsidian5 = require("obsidian");
var TwoFieldModal = class extends import_obsidian5.Modal {
  constructor(app, title, label1, placeholder1, label2, placeholder2, onSubmit) {
    super(app);
    this.data = { field1: "", field2: "" };
    this.title = title;
    this.label1 = label1;
    this.placeholder1 = placeholder1;
    this.label2 = label2;
    this.placeholder2 = placeholder2;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText(this.title);
    new import_obsidian5.Setting(contentEl).setName(this.label1).addText((text) => {
      text.setPlaceholder(this.placeholder1).onChange((value) => {
        this.data.field1 = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          const nextInput = contentEl.querySelectorAll("input")[1];
          if (nextInput) {
            nextInput.focus();
          }
        }
      });
    });
    new import_obsidian5.Setting(contentEl).setName(this.label2).addText((text) => {
      text.setPlaceholder(this.placeholder2).onChange((value) => {
        this.data.field2 = value.trim();
      });
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submit();
        }
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  submit() {
    if (!this.data.field1 || !this.data.field2) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please fill in all fields",
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.data);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/assignment-modal.ts
var import_obsidian6 = require("obsidian");
var AssignmentModal = class extends import_obsidian6.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.data = {
      title: "",
      points: 0,
      dueDate: "",
      dueTime: "11:59pm",
      gradeDisplay: "complete_incomplete",
      submissionTypes: "online_text_entry"
    };
    this.selectedSubmissionTypes = /* @__PURE__ */ new Set(["online_text_entry"]);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Insert Canvas Assignment");
    new import_obsidian6.Setting(contentEl).setName("Assignment title").setDesc("Required").addText((text) => {
      text.setPlaceholder("Enter assignment title").onChange((value) => {
        this.data.title = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
    });
    new import_obsidian6.Setting(contentEl).setName("Points").setDesc("Default: 0").addText((text) => {
      text.setPlaceholder("0").onChange((value) => {
        const num = parseInt(value);
        this.data.points = isNaN(num) ? 0 : num;
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Due date").setDesc("Format: 2026-01-15 or leave blank").addText((text) => {
      text.setPlaceholder("YYYY-MM-DD (optional)").onChange((value) => {
        this.data.dueDate = value.trim();
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Due time").setDesc("Default: 11:59pm").addText((text) => {
      text.setPlaceholder("11:59pm").setValue("11:59pm").onChange((value) => {
        this.data.dueTime = value.trim() || "11:59pm";
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Grade display").setDesc("How grades are displayed").addDropdown((dropdown) => {
      dropdown.addOption("complete_incomplete", "Complete/Incomplete").addOption("points", "Points").addOption("not_graded", "Not Graded").setValue("complete_incomplete").onChange((value) => {
        this.data.gradeDisplay = value;
      });
    });
    contentEl.createEl("h3", { text: "Submission types" });
    contentEl.createEl("p", {
      text: "Select one or more submission methods",
      cls: "setting-item-description"
    });
    const submissionContainer = contentEl.createDiv({ cls: "submission-types-container" });
    new import_obsidian6.Setting(submissionContainer).setName("Online text entry").addToggle((toggle) => {
      toggle.setValue(true).onChange((value) => {
        this.toggleSubmissionType("online_text_entry", value);
      });
    });
    new import_obsidian6.Setting(submissionContainer).setName("File upload").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.toggleSubmissionType("online_upload", value);
      });
    });
    new import_obsidian6.Setting(submissionContainer).setName("URL submission").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.toggleSubmissionType("online_url", value);
      });
    });
    new import_obsidian6.Setting(submissionContainer).setName("Media recording").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.toggleSubmissionType("media_recording", value);
      });
    });
    new import_obsidian6.Setting(submissionContainer).setName("No submission").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.toggleSubmissionType("none", value);
      });
    });
    new import_obsidian6.Setting(submissionContainer).setName("On paper").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.toggleSubmissionType("on_paper", value);
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  toggleSubmissionType(type, enabled) {
    if (enabled) {
      this.selectedSubmissionTypes.add(type);
    } else {
      this.selectedSubmissionTypes.delete(type);
    }
    this.data.submissionTypes = Array.from(this.selectedSubmissionTypes).join(", ");
  }
  submit() {
    if (!this.data.title) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please enter an assignment title",
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    if (this.selectedSubmissionTypes.size === 0) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please select at least one submission type",
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.data);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/discussion-modal.ts
var import_obsidian7 = require("obsidian");
var DiscussionModal = class extends import_obsidian7.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.data = {
      title: "",
      requireInitialPost: false,
      threaded: true,
      graded: false,
      points: 0,
      dueDate: "",
      dueTime: "11:59pm",
      gradeDisplay: "complete_incomplete"
    };
    this.gradingFields = null;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Insert Canvas Discussion");
    new import_obsidian7.Setting(contentEl).setName("Discussion title").setDesc("Required").addText((text) => {
      text.setPlaceholder("Enter discussion title").onChange((value) => {
        this.data.title = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
    });
    new import_obsidian7.Setting(contentEl).setName("Require initial post").setDesc("Students must post before seeing others' posts").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.data.requireInitialPost = value;
      });
    });
    new import_obsidian7.Setting(contentEl).setName("Threaded").setDesc("Enable threaded replies").addToggle((toggle) => {
      toggle.setValue(true).onChange((value) => {
        this.data.threaded = value;
      });
    });
    new import_obsidian7.Setting(contentEl).setName("Graded").setDesc("Enable grading for this discussion").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.data.graded = value;
        this.toggleGradingFields(value);
      });
    });
    this.gradingFields = contentEl.createDiv({ cls: "grading-fields" });
    this.gradingFields.style.display = "none";
    new import_obsidian7.Setting(this.gradingFields).setName("Points").setDesc("Points for this discussion").addText((text) => {
      text.setPlaceholder("0").onChange((value) => {
        const num = parseInt(value);
        this.data.points = isNaN(num) ? 0 : num;
      });
    });
    new import_obsidian7.Setting(this.gradingFields).setName("Due date").setDesc("Format: 2026-01-15").addText((text) => {
      text.setPlaceholder("YYYY-MM-DD").onChange((value) => {
        this.data.dueDate = value.trim();
      });
    });
    new import_obsidian7.Setting(this.gradingFields).setName("Due time").setDesc("Default: 11:59pm").addText((text) => {
      text.setPlaceholder("11:59pm").setValue("11:59pm").onChange((value) => {
        this.data.dueTime = value.trim() || "11:59pm";
      });
    });
    new import_obsidian7.Setting(this.gradingFields).setName("Grade display").setDesc("How grades are displayed").addDropdown((dropdown) => {
      dropdown.addOption("complete_incomplete", "Complete/Incomplete").addOption("points", "Points").addOption("not_graded", "Not Graded").setValue("complete_incomplete").onChange((value) => {
        this.data.gradeDisplay = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  toggleGradingFields(show) {
    if (this.gradingFields) {
      this.gradingFields.style.display = show ? "block" : "none";
    }
  }
  submit() {
    if (!this.data.title) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please enter a discussion title",
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.data);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/internal-link-modal.ts
var import_obsidian8 = require("obsidian");
var InternalLinkModal = class extends import_obsidian8.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.data = {
      type: "Page",
      name: ""
    };
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Insert Canvas Internal Link");
    contentEl.createEl("p", {
      text: "Create a cross-reference to another Canvas item",
      cls: "mod-muted"
    });
    new import_obsidian8.Setting(contentEl).setName("Link type").setDesc("Type of content to link to").addDropdown((dropdown) => {
      dropdown.addOption("Page", "Page").addOption("Assignment", "Assignment").addOption("Discussion", "Discussion").addOption("File", "File").setValue("Page").onChange((value) => {
        this.data.type = value;
      });
    });
    new import_obsidian8.Setting(contentEl).setName("Item name").setDesc("Name of the item to link to").addText((text) => {
      text.setPlaceholder("Enter item name").onChange((value) => {
        this.data.name = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submit();
        }
      });
    });
    contentEl.createEl("p", {
      text: "Example: [[Page:Course Policies]] or [[Assignment:Homework 1]]",
      cls: "mod-muted"
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Insert",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  submit() {
    if (!this.data.name) {
      const existingError = this.contentEl.querySelector(".template-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please enter an item name",
        cls: "template-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.data);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/content-type-modal.ts
var import_obsidian9 = require("obsidian");
var ContentTypeModal = class extends import_obsidian9.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.selectedType = "module";
    this.contentTypes = [
      {
        value: "module",
        label: "Module",
        description: "Top-level course section (H1)"
      },
      {
        value: "header",
        label: "Header",
        description: "Text header within a module"
      },
      {
        value: "page",
        label: "Page",
        description: "Wiki-style content page"
      },
      {
        value: "link",
        label: "External Link",
        description: "Link to external URL"
      },
      {
        value: "file",
        label: "File",
        description: "Reference to Canvas file"
      },
      {
        value: "assignment",
        label: "Assignment",
        description: "Graded assignment with metadata"
      },
      {
        value: "discussion",
        label: "Discussion",
        description: "Discussion board with optional grading"
      },
      {
        value: "internal-link",
        label: "Internal Link",
        description: "Cross-reference to another Canvas item"
      }
    ];
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Add Canvas Content");
    contentEl.createEl("p", {
      text: "Select the type of content to insert"
    });
    new import_obsidian9.Setting(contentEl).setName("Content type").addDropdown((dropdown) => {
      this.contentTypes.forEach((type) => {
        dropdown.addOption(type.value, type.label);
      });
      dropdown.setValue("module").onChange((value) => {
        this.selectedType = value;
        this.updateDescription(value);
      });
    });
    const descEl = contentEl.createEl("p", {
      text: this.contentTypes[0].description,
      cls: "mod-muted content-type-description"
    });
    this.updateDescription = (type) => {
      const option = this.contentTypes.find((t) => t.value === type);
      if (option) {
        descEl.setText(option.description);
      }
    };
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Next",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
    setTimeout(() => {
      const dropdown = contentEl.querySelector("select");
      if (dropdown) dropdown.focus();
    }, 10);
  }
  submit() {
    this.close();
    this.onSubmit(this.selectedType);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/upload-preview-modal.ts
var import_obsidian10 = require("obsidian");
var UploadPreviewModal = class extends import_obsidian10.Modal {
  constructor(app, preview, onConfirm) {
    super(app);
    this.preview = preview;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Upload preview");
    contentEl.createEl("p", {
      text: "Review changes before uploading to Canvas:"
    });
    const previewContainer = contentEl.createDiv({ cls: "upload-preview-container" });
    for (const item of this.preview) {
      this.renderPreviewItem(previewContainer, item);
    }
    const totals = this.calculateTotals();
    const summary = contentEl.createDiv({ cls: "upload-preview-summary" });
    summary.createEl("strong", { text: "Summary: " });
    summary.createEl("span", {
      text: `${totals.create} to create, ${totals.update} to update, ${totals.skip} unchanged`,
      cls: "mod-muted"
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const uploadButton = buttonContainer.createEl("button", {
      text: "Upload to Canvas",
      cls: "mod-cta"
    });
    uploadButton.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  /**
   * Render a single preview item (module)
   */
  renderPreviewItem(container, item) {
    const moduleDiv = container.createDiv({ cls: "upload-preview-module" });
    const moduleHeader = moduleDiv.createDiv({ cls: "upload-preview-module-header" });
    moduleHeader.createEl("strong", { text: `[Module] ${item.moduleTitle}` });
    if (item.modulAction && item.modulAction !== "skip") {
      const actionBadge = moduleHeader.createEl("span", {
        cls: `upload-preview-badge upload-preview-badge-${item.modulAction}`
      });
      actionBadge.setText(item.modulAction.toUpperCase());
      if (item.moduleChangedFields && item.moduleChangedFields.length > 0) {
        moduleHeader.createEl("span", {
          text: ` (${item.moduleChangedFields.join(", ")})`,
          cls: "mod-muted"
        });
      }
    }
    for (const detail of item.items) {
      this.renderItemDetail(moduleDiv, detail);
    }
  }
  /**
   * Render a single item detail
   */
  renderItemDetail(container, detail) {
    const itemDiv = container.createDiv({ cls: "upload-preview-item" });
    const itemLine = itemDiv.createDiv({ cls: "upload-preview-item-line" });
    itemLine.createEl("span", { text: "  \u2022 ", cls: "upload-preview-bullet" });
    itemLine.createEl("span", {
      text: `[${detail.type}] ${detail.title}`,
      cls: "upload-preview-item-title"
    });
    const actionBadge = itemLine.createEl("span", {
      cls: `upload-preview-badge upload-preview-badge-${detail.action}`
    });
    actionBadge.setText(detail.action.toUpperCase());
    if (detail.changedFields && detail.changedFields.length > 0) {
      itemLine.createEl("span", {
        text: ` (${detail.changedFields.join(", ")})`,
        cls: "mod-muted"
      });
    }
    if (detail.metadata && Object.keys(detail.metadata).length > 0) {
      const metadataDiv = itemDiv.createDiv({ cls: "upload-preview-metadata" });
      for (const [key, value] of Object.entries(detail.metadata)) {
        metadataDiv.createEl("div", {
          text: `      ${key}: ${value}`,
          cls: "upload-preview-metadata-line"
        });
      }
    }
  }
  /**
   * Calculate totals for summary
   */
  calculateTotals() {
    let create = 0;
    let update = 0;
    let skip = 0;
    for (const item of this.preview) {
      if (item.modulAction === "create") create++;
      else if (item.modulAction === "update") update++;
      else if (item.modulAction === "skip") skip++;
      for (const detail of item.items) {
        if (detail.action === "create") create++;
        else if (detail.action === "update") update++;
        else if (detail.action === "skip") skip++;
      }
    }
    return { create, update, skip };
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/folder-picker-modal.ts
var import_obsidian11 = require("obsidian");
var FolderPickerModal = class extends import_obsidian11.Modal {
  constructor(app, defaultFolder, onSubmit) {
    super(app);
    this.folderPath = "";
    this.submitted = false;
    this.folderPath = defaultFolder;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Save Course");
    const folders = this.getAllFolders();
    new import_obsidian11.Setting(contentEl).setName("Folder").setDesc("Select where to save the course file").addDropdown((dropdown) => {
      dropdown.addOption("", "/ (root)");
      folders.forEach((folder) => {
        dropdown.addOption(folder, folder);
      });
      dropdown.setValue(this.folderPath);
      dropdown.onChange((value) => {
        this.folderPath = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Save",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  getAllFolders() {
    const folders = [];
    const files = this.app.vault.getAllLoadedFiles();
    files.forEach((file) => {
      if (file instanceof import_obsidian11.TFolder) {
        folders.push(file.path);
      }
    });
    folders.sort((a, b) => a.localeCompare(b));
    return folders;
  }
  submit() {
    this.submitted = true;
    this.close();
    this.onSubmit(this.folderPath);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (!this.submitted) {
      this.onSubmit(null);
    }
  }
};

// src/templates/template-builders.ts
function buildModule(data) {
  return `# ${data.title}
`;
}
function buildHeader(data) {
  return `
## [header] ${data.title}
`;
}
function buildPage(data) {
  return `
## [page] ${data.title}
`;
}
function buildLink(data) {
  return `
## [link] ${data.title}
url: ${data.url}
`;
}
function buildFile(data) {
  return `
## [file] ${data.title}
filename: ${data.filename}
`;
}
function buildAssignment(data) {
  let md = `
## [assignment] ${data.title}
`;
  if (data.points !== void 0 && data.points !== 0) {
    md += `points: ${data.points}
`;
  }
  if (data.dueDate) {
    const time = data.dueTime || "11:59pm";
    md += `due: ${data.dueDate} ${time}
`;
  }
  if (data.gradeDisplay && data.gradeDisplay !== "complete_incomplete") {
    md += `grade_display: ${data.gradeDisplay}
`;
  }
  if (data.submissionTypes && data.submissionTypes !== "online_text_entry") {
    md += `submission_types: ${data.submissionTypes}
`;
  }
  md += "\n---\n";
  return md;
}
function buildDiscussion(data) {
  let md = `
## [discussion] ${data.title}
`;
  if (data.requireInitialPost !== void 0) {
    md += `require_initial_post: ${data.requireInitialPost}
`;
  }
  if (data.threaded !== void 0 && data.threaded !== true) {
    md += `threaded: ${data.threaded}
`;
  }
  if (data.graded !== void 0) {
    md += `graded: ${data.graded}
`;
  }
  if (data.graded) {
    if (data.points !== void 0) {
      md += `points: ${data.points}
`;
    }
    if (data.dueDate) {
      const time = data.dueTime || "11:59pm";
      md += `due: ${data.dueDate} ${time}
`;
    }
    if (data.gradeDisplay) {
      md += `grade_display: ${data.gradeDisplay}
`;
    }
  }
  md += "\n---\n";
  return md;
}
function buildInternalLink(data) {
  return `[[${data.type}:${data.name}]]`;
}

// src/utils/editor-utils.ts
function insertAtCursor(editor, text) {
  const cursor = editor.getCursor();
  editor.replaceRange(text, cursor);
  const lines = text.split("\n");
  const newLine = cursor.line + lines.length - 1;
  const newCh = lines.length === 1 ? cursor.ch + text.length : lines[lines.length - 1].length;
  editor.setCursor({ line: newLine, ch: newCh });
}

// src/upload/parser.ts
var MarkdownParser = class {
  constructor(content) {
    this.currentLine = 0;
    this.content = content;
    this.lines = content.split("\n");
  }
  /**
   * Parse the entire markdown file
   */
  parse() {
    const frontmatter = this.parseFrontmatter();
    const modules = this.parseModules();
    return { frontmatter, modules };
  }
  /**
   * Parse YAML frontmatter
   */
  parseFrontmatter() {
    var _a;
    const frontmatter = {};
    if (((_a = this.lines[this.currentLine]) == null ? void 0 : _a.trim()) === "---") {
      this.currentLine++;
      while (this.currentLine < this.lines.length) {
        const line = this.lines[this.currentLine];
        if (line.trim() === "---") {
          this.currentLine++;
          break;
        }
        const match = line.match(/^(\w+):\s*(.+)$/);
        if (match) {
          const [, key, value] = match;
          if (key === "canvas_course_id" || key === "canvas_url") {
            frontmatter[key] = value.trim();
          }
        }
        this.currentLine++;
      }
    }
    return frontmatter;
  }
  /**
   * Parse all modules
   */
  parseModules() {
    const modules = [];
    while (this.currentLine < this.lines.length) {
      const line = this.lines[this.currentLine];
      if (line.startsWith("# ")) {
        const module2 = this.parseModule();
        modules.push(module2);
      } else {
        this.currentLine++;
      }
    }
    return modules;
  }
  /**
   * Parse a single module
   */
  parseModule() {
    const titleLine = this.lines[this.currentLine];
    const title = titleLine.replace(/^#\s+/, "").trim();
    this.currentLine++;
    let canvasModuleId;
    if (this.currentLine < this.lines.length) {
      const commentMatch = this.lines[this.currentLine].match(/<!--\s*canvas_module_id:\s*(\d+)\s*-->/);
      if (commentMatch) {
        canvasModuleId = parseInt(commentMatch[1], 10);
        this.currentLine++;
      }
    }
    const items = [];
    while (this.currentLine < this.lines.length) {
      const line = this.lines[this.currentLine];
      if (line.startsWith("# ")) {
        break;
      }
      if (line.startsWith("## ")) {
        const item = this.parseModuleItem();
        if (item) {
          items.push(item);
        }
      } else {
        this.currentLine++;
      }
    }
    return { title, canvasModuleId, items };
  }
  /**
   * Parse a single module item
   */
  parseModuleItem() {
    const titleLine = this.lines[this.currentLine];
    const match = titleLine.match(/^##\s+\[(\w+)\]\s+(.+)$/);
    if (!match) {
      this.currentLine++;
      return null;
    }
    const [, type, title] = match;
    this.currentLine++;
    switch (type.toLowerCase()) {
      case "page":
        return this.parsePage(title);
      case "assignment":
        return this.parseAssignment(title);
      case "discussion":
        return this.parseDiscussion(title);
      case "header":
        return this.parseHeader(title);
      case "link":
        return this.parseLink(title);
      case "file":
        return this.parseFile(title);
      default:
        console.warn(`Unknown item type: ${type}`);
        return null;
    }
  }
  /**
   * Parse Canvas IDs and module item ID from comments
   */
  parseIds() {
    const ids = {};
    while (this.currentLine < this.lines.length) {
      const line = this.lines[this.currentLine];
      if (!line.trim().startsWith("<!--")) {
        break;
      }
      const pageIdMatch = line.match(/<!--\s*canvas_page_id:\s*(\S+)\s*-->/);
      if (pageIdMatch) {
        ids.canvasId = pageIdMatch[1];
        this.currentLine++;
        continue;
      }
      const assignmentIdMatch = line.match(/<!--\s*canvas_assignment_id:\s*(\d+)\s*-->/);
      if (assignmentIdMatch) {
        ids.canvasId = parseInt(assignmentIdMatch[1], 10);
        this.currentLine++;
        continue;
      }
      const discussionIdMatch = line.match(/<!--\s*canvas_discussion_id:\s*(\d+)\s*-->/);
      if (discussionIdMatch) {
        ids.canvasId = parseInt(discussionIdMatch[1], 10);
        this.currentLine++;
        continue;
      }
      const fileIdMatch = line.match(/<!--\s*canvas_file_id:\s*(\d+)\s*-->/);
      if (fileIdMatch) {
        ids.canvasId = parseInt(fileIdMatch[1], 10);
        this.currentLine++;
        continue;
      }
      const moduleItemIdMatch = line.match(/<!--\s*canvas_module_item_id:\s*(\d+)\s*-->/);
      if (moduleItemIdMatch) {
        ids.moduleItemId = parseInt(moduleItemIdMatch[1], 10);
        this.currentLine++;
        continue;
      }
      this.currentLine++;
    }
    return ids;
  }
  /**
   * Unescape markdown content (handle escaped brackets)
   */
  unescapeMarkdown(content) {
    return content.replace(/\\\[/g, "[").replace(/\\\]/g, "]");
  }
  /**
   * Parse metadata fields and content
   */
  parseMetadataAndContent() {
    const metadata = {};
    let content = "";
    let inContent = false;
    while (this.currentLine < this.lines.length) {
      const line = this.lines[this.currentLine];
      if (line.startsWith("# ") || this.isModuleItemHeader(line)) {
        break;
      }
      if (line.trim() === "---") {
        inContent = true;
        this.currentLine++;
        continue;
      }
      if (inContent) {
        content += line + "\n";
      } else {
        const metaMatch = line.match(/^(\w+):\s*(.+)$/);
        if (metaMatch) {
          const [, key, value] = metaMatch;
          metadata[key] = this.parseMetadataValue(key, value);
        }
      }
      this.currentLine++;
    }
    return { metadata, content: this.unescapeMarkdown(content.trim()) };
  }
  /**
   * Parse metadata value (handle different types)
   */
  parseMetadataValue(key, value) {
    if (value === "null") return null;
    if (value === "true") return true;
    if (value === "false") return false;
    if (key === "points" && /^\d+(\.\d+)?$/.test(value)) {
      return parseFloat(value);
    }
    if (key === "due") {
      return this.parseDate(value);
    }
    if (key === "submission_types") {
      return value.split(",").map((s) => s.trim());
    }
    return value;
  }
  /**
   * Parse date from various formats to ISO 8601
   * Formats: "2026-01-20 11:59pm", "2026-01-20", ISO 8601
   */
  parseDate(dateStr) {
    if (!dateStr) return void 0;
    try {
      const timeMatch = dateStr.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{1,2}):(\d{2})(am|pm)$/i);
      if (timeMatch) {
        const [, datePart, hourStr, minuteStr, ampm] = timeMatch;
        let hour = parseInt(hourStr, 10);
        const minute = parseInt(minuteStr, 10);
        if (ampm.toLowerCase() === "pm" && hour !== 12) {
          hour += 12;
        } else if (ampm.toLowerCase() === "am" && hour === 12) {
          hour = 0;
        }
        const date2 = /* @__PURE__ */ new Date(`${datePart}T${String(hour).padStart(2, "0")}:${String(minute).padStart(2, "0")}:00`);
        return date2.toISOString();
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
        const date2 = /* @__PURE__ */ new Date(`${dateStr}T00:00:00`);
        return date2.toISOString();
      }
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        return date.toISOString();
      }
      console.warn(`Could not parse date: ${dateStr}`);
      return void 0;
    } catch (error) {
      console.warn(`Error parsing date "${dateStr}":`, error);
      return void 0;
    }
  }
  /**
   * Parse a page item
   */
  parsePage(title) {
    const ids = this.parseIds();
    let content = "";
    while (this.currentLine < this.lines.length) {
      const line = this.lines[this.currentLine];
      if (line.startsWith("# ") || this.isModuleItemHeader(line)) {
        break;
      }
      content += line + "\n";
      this.currentLine++;
    }
    return {
      type: "page",
      title,
      canvasPageId: ids.canvasId,
      canvasModuleItemId: ids.moduleItemId,
      body: this.unescapeMarkdown(content.trim())
    };
  }
  /**
   * Check if a line is a module item header (## [type] Title)
   */
  isModuleItemHeader(line) {
    return /^##\s+\[(page|assignment|discussion|header|link|file)\]\s+/.test(line);
  }
  /**
   * Parse an assignment item
   */
  parseAssignment(title) {
    const ids = this.parseIds();
    const { metadata, content } = this.parseMetadataAndContent();
    return {
      type: "assignment",
      title,
      canvasAssignmentId: ids.canvasId,
      canvasModuleItemId: ids.moduleItemId,
      description: content,
      pointsPossible: metadata.points,
      dueAt: metadata.due,
      gradingType: metadata.grade_display,
      submissionTypes: metadata.submission_types
    };
  }
  /**
   * Parse a discussion item
   */
  parseDiscussion(title) {
    var _a, _b, _c;
    const ids = this.parseIds();
    const { metadata, content } = this.parseMetadataAndContent();
    return {
      type: "discussion",
      title,
      canvasDiscussionId: ids.canvasId,
      canvasModuleItemId: ids.moduleItemId,
      message: content,
      requireInitialPost: (_a = metadata.require_initial_post) != null ? _a : null,
      threaded: (_b = metadata.threaded) != null ? _b : true,
      graded: (_c = metadata.graded) != null ? _c : false,
      pointsPossible: metadata.points,
      dueAt: metadata.due
    };
  }
  /**
   * Parse a header item
   */
  parseHeader(title) {
    const ids = this.parseIds();
    this.parseMetadataAndContent();
    return {
      type: "header",
      title,
      canvasModuleItemId: ids.moduleItemId
    };
  }
  /**
   * Parse a link item
   */
  parseLink(title) {
    const ids = this.parseIds();
    const { metadata } = this.parseMetadataAndContent();
    return {
      type: "link",
      title,
      canvasModuleItemId: ids.moduleItemId,
      url: metadata.url || ""
    };
  }
  /**
   * Parse a file item
   */
  parseFile(title) {
    const ids = this.parseIds();
    const { metadata } = this.parseMetadataAndContent();
    return {
      type: "file",
      title,
      canvasFileId: ids.canvasId,
      canvasModuleItemId: ids.moduleItemId,
      filename: metadata.filename
    };
  }
};

// src/canvas/api-client-write.ts
var import_obsidian12 = require("obsidian");
var CanvasApiClientWrite = class extends CanvasApiClient {
  constructor(baseUrl, token, courseId) {
    super(baseUrl, token);
    this._baseUrl = baseUrl.replace(/\/$/, "");
    this._token = token;
    this.courseId = courseId;
  }
  /**
   * Make a generic POST/PUT request to Canvas
   */
  async writeRequest(endpoint, method, params) {
    var _a;
    const url = `${this._baseUrl}${endpoint}`;
    const formData = new URLSearchParams();
    this.buildFormData(formData, params);
    try {
      const response = await (0, import_obsidian12.requestUrl)({
        url,
        method,
        headers: {
          "Authorization": `Bearer ${this._token}`,
          "Content-Type": "application/x-www-form-urlencoded",
          "Accept": "application/json"
        },
        body: formData.toString()
      });
      if (response.status === 200 || response.status === 201) {
        return response.json;
      } else {
        throw new Error(`HTTP ${response.status}: ${response.text}`);
      }
    } catch (error) {
      if (error.status === 401) {
        throw new Error("Invalid Canvas token. Please check your settings.");
      } else if (error.status === 403) {
        throw new Error("Access denied. You may not have permission to modify this course.");
      } else if (error.status === 404) {
        throw new Error("Resource not found. The Canvas ID may be stale.");
      } else if (error.status === 422) {
        throw new Error(`Validation error: ${error.text || "Invalid data"}`);
      } else if ((_a = error.message) == null ? void 0 : _a.includes("net::")) {
        throw new Error("Cannot connect to Canvas. Check your internet connection.");
      } else {
        throw error;
      }
    }
  }
  /**
   * Build form data from params object
   * Handles nested objects and arrays for Canvas API
   */
  buildFormData(formData, params, prefix = "") {
    for (const [key, value] of Object.entries(params)) {
      if (value === void 0 || value === null) {
        continue;
      }
      const formKey = prefix ? `${prefix}[${key}]` : key;
      if (Array.isArray(value)) {
        value.forEach((item) => {
          formData.append(`${formKey}[]`, String(item));
        });
      } else if (typeof value === "object") {
        this.buildFormData(formData, value, formKey);
      } else {
        formData.append(formKey, String(value));
      }
    }
  }
  /**
   * MODULE OPERATIONS
   */
  async createModule(params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/modules`,
      "POST",
      { module: params }
    );
  }
  async updateModule(moduleId, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/modules/${moduleId}`,
      "PUT",
      { module: params }
    );
  }
  /**
   * PAGE OPERATIONS
   */
  async createPage(params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/pages`,
      "POST",
      { wiki_page: params }
    );
  }
  async updatePage(pageUrl, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/pages/${pageUrl}`,
      "PUT",
      { wiki_page: params }
    );
  }
  /**
   * ASSIGNMENT OPERATIONS
   */
  async createAssignment(params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/assignments`,
      "POST",
      { assignment: params }
    );
  }
  async updateAssignment(assignmentId, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/assignments/${assignmentId}`,
      "PUT",
      { assignment: params }
    );
  }
  /**
   * DISCUSSION OPERATIONS
   */
  async createDiscussion(params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/discussion_topics`,
      "POST",
      params
    );
  }
  async updateDiscussion(topicId, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/discussion_topics/${topicId}`,
      "PUT",
      params
    );
  }
  /**
   * MODULE ITEM OPERATIONS
   */
  async createModuleItem(moduleId, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/modules/${moduleId}/items`,
      "POST",
      { module_item: params }
    );
  }
  async updateModuleItem(moduleId, itemId, params) {
    return await this.writeRequest(
      `/api/v1/courses/${this.courseId}/modules/${moduleId}/items/${itemId}`,
      "PUT",
      { module_item: params }
    );
  }
};

// src/upload/link-resolver.ts
var LinkResolver = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  /**
   * Register a content item with its Canvas URL
   */
  register(type, title, canvasUrl) {
    const key = this.makeKey(type, title);
    this.registry.set(key, canvasUrl);
  }
  /**
   * Resolve [[Type:Title]] links in content to Canvas URLs
   */
  resolve(content) {
    if (!content) {
      return { resolved: content, hasLinks: false };
    }
    let hasLinks = false;
    let resolved = content;
    const linkPattern = /\[\[(\w+):([^\]]+)\]\]/g;
    resolved = content.replace(linkPattern, (match, type, title) => {
      const key = this.makeKey(type, title);
      const url = this.registry.get(key);
      if (url) {
        hasLinks = true;
        return `<a href="${url}">${title.trim()}</a>`;
      } else {
        console.warn(`Link not found: ${match}`);
        return title.trim();
      }
    });
    return { resolved, hasLinks };
  }
  /**
   * Check if content has internal links
   */
  hasInternalLinks(content) {
    if (!content) return false;
    return /\[\[(\w+):([^\]]+)\]\]/.test(content);
  }
  /**
   * Make registry key from type and title (normalized)
   */
  makeKey(type, title) {
    return `${type.toLowerCase()}:${title.trim().toLowerCase()}`;
  }
  /**
   * Clear the registry
   */
  clear() {
    this.registry.clear();
  }
  /**
   * Get all registered items (for debugging)
   */
  getRegistry() {
    return new Map(this.registry);
  }
};

// src/canvas/html-normalizer.ts
function decodeHtmlEntities(text) {
  const entities = {
    "&nbsp;": " ",
    "&amp;": "&",
    "&lt;": "<",
    "&gt;": ">",
    "&quot;": '"',
    "&#39;": "'",
    "&apos;": "'",
    "&ndash;": "\u2013",
    "&mdash;": "\u2014",
    "&lsquo;": "'",
    "&rsquo;": "'",
    "&ldquo;": '"',
    "&rdquo;": '"',
    "&hellip;": "..."
  };
  let decoded = text;
  for (const [entity, char] of Object.entries(entities)) {
    decoded = decoded.replace(new RegExp(entity, "g"), char);
  }
  decoded = decoded.replace(/&#(\d+);/g, (_, num) => {
    return String.fromCharCode(parseInt(num, 10));
  });
  decoded = decoded.replace(/&#x([0-9a-f]+);/gi, (_, hex) => {
    return String.fromCharCode(parseInt(hex, 16));
  });
  return decoded;
}
function normalizeUnicode(text) {
  return text.replace(/[\u2018\u2019\u201A\u201B]/g, "'").replace(/[\u201C\u201D\u201E\u201F]/g, '"').replace(/[\u2013\u2014\u2015]/g, "-").replace(/\u2026/g, "...").replace(/\u00A0/g, " ");
}
function stripHtmlTags(html) {
  let result = html.replace(/<br\s*\/?>/gi, " ");
  result = result.replace(/<[^>]+>/g, "");
  return result;
}
function normalizeWhitespace(text) {
  return text.replace(/\s+/g, " ").trim();
}
function normalizeHtml(content) {
  if (!content) return "";
  let normalized = content;
  normalized = decodeHtmlEntities(normalized);
  normalized = stripHtmlTags(normalized);
  normalized = normalizeUnicode(normalized);
  normalized = normalized.replace(/\\([_*\[\]\\`#+-])/g, "$1");
  normalized = normalized.replace(/\[(https?:\/\/[^\]]+)\]\(\1\)/g, "$1");
  normalized = normalized.replace(/\[(https?:\/\/[^\]]+)\]/g, "$1");
  normalized = normalized.replace(/\((https?:\/\/[^)]+)\)/g, "$1");
  normalized = normalized.replace(/_+(\[)/g, "$1");
  normalized = normalized.replace(/(\])_+/g, "$1");
  normalized = normalized.replace(/__{2,}/g, "");
  normalized = normalized.replace(/\s_+\s/g, " ");
  normalized = normalized.replace(/\s*-\s*/g, "-");
  normalized = normalizeWhitespace(normalized);
  normalized = normalized.toLowerCase();
  return normalized;
}
function compareHtmlContent(content1, content2) {
  const normalized1 = normalizeHtml(content1);
  const normalized2 = normalizeHtml(content2);
  return normalized1 === normalized2;
}
function markdownToSimpleHtml(markdown) {
  if (!markdown) return "";
  let html = markdown;
  html = html.replace(/\\([_*\[\]\\`#+()\-!])/g, "$1");
  html = html.replace(/^######\s+(.+)$/gm, "<h4>$1</h4>");
  html = html.replace(/^#####\s+(.+)$/gm, "<h3>$1</h3>");
  html = html.replace(/^####\s+(.+)$/gm, "<h2>$1</h2>");
  html = html.replace(/^###\s+(.+)$/gm, "<h1>$1</h1>");
  html = html.replace(/^##\s+(.+)$/gm, "<h1>$1</h1>");
  html = html.replace(/^#\s+(.+)$/gm, "<h1>$1</h1>");
  html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img alt="$1" src="$2">');
  html = html.replace(/^\s*-\s+(.+)$/gm, "<li>$1</li>");
  html = html.replace(/^\s*\*\s+(.+)$/gm, "<li>$1</li>");
  html = html.replace(/^\s*\d+\.\s+(.+)$/gm, "<li>$1</li>");
  html = html.replace(/(<li>.*<\/li>\s*)+/gs, "<ul>$&</ul>");
  html = html.replace(/(<\/li>)\n+(<li>)/g, "$1$2");
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
  html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
  html = html.replace(/__(.+?)__/g, "<strong>$1</strong>");
  const attrPlaceholders = [];
  html = html.replace(/(href|src|alt)="([^"]+)"/g, (match) => {
    attrPlaceholders.push(match);
    return `###ATTR${attrPlaceholders.length - 1}###`;
  });
  html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
  html = html.replace(/_(.+?)_/g, "<em>$1</em>");
  html = html.replace(/###ATTR(\d+)###/g, (_, index) => {
    return attrPlaceholders[parseInt(index)];
  });
  html = html.replace(/`(.+?)`/g, "<code>$1</code>");
  html = html.replace(/\n\s*\n/g, "<<<PARAGRAPH_BREAK>>>");
  html = html.replace(/\n/g, "<br>\n");
  html = html.replace(/<<<PARAGRAPH_BREAK>>>/g, "\n\n");
  const blocks = html.split(/\n\s*\n/);
  html = blocks.map((block) => {
    const trimmed = block.trim();
    if (!trimmed) return "";
    if (trimmed.match(/^<(h[1-6]|ul|ol|li|div|p|blockquote|img)/)) {
      return trimmed;
    }
    return `<p>${trimmed}</p>`;
  }).filter((b) => b).join("");
  return html;
}

// src/upload/comparator.ts
var debugMode = false;
function setComparatorDebug(enabled) {
  debugMode = enabled;
}
function log(...args) {
  if (debugMode) {
    console.log("[Comparator]", ...args);
  }
}
function compareModule(parsed, canvas) {
  if (!canvas) {
    return {
      hasChanges: true,
      changedFields: [],
      action: "create"
    };
  }
  const changedFields = [];
  if (parsed.title !== canvas.name) {
    changedFields.push("title");
  }
  if (changedFields.length > 0) {
    return {
      hasChanges: true,
      changedFields,
      action: "update"
    };
  }
  return {
    hasChanges: false,
    changedFields: [],
    action: "skip"
  };
}
function comparePage(parsed, canvas) {
  log(`      Comparing page: "${parsed.title}"`);
  if (!canvas) {
    log(`      No Canvas data found - marking as CREATE`);
    return {
      hasChanges: true,
      changedFields: [],
      action: "create"
    };
  }
  const changedFields = [];
  if (parsed.title !== canvas.title) {
    log(`      Title changed: "${parsed.title}" !== "${canvas.title}"`);
    changedFields.push("title");
  }
  const parsedBodyHtml = markdownToSimpleHtml(parsed.body);
  const canvasBodyHtml = canvas.body || "";
  const parsedNormalized = normalizeHtml(parsedBodyHtml);
  const canvasNormalized = normalizeHtml(canvasBodyHtml);
  const match = parsedNormalized === canvasNormalized;
  if (!match) {
    log(`      Body changed (normalized comparison failed)`);
    log(`      Parsed body (raw, first 200): "${parsed.body.substring(0, 200)}..."`);
    log(`      Canvas body (raw, first 200): "${canvasBodyHtml.substring(0, 200)}..."`);
    log(`      Parsed (normalized, first 200): "${parsedNormalized.substring(0, 200)}..."`);
    log(`      Canvas (normalized, first 200): "${canvasNormalized.substring(0, 200)}..."`);
    for (let i = 0; i < Math.min(parsedNormalized.length, canvasNormalized.length); i++) {
      if (parsedNormalized[i] !== canvasNormalized[i]) {
        log(`      First difference at position ${i}:`);
        log(`        Parsed char: "${parsedNormalized[i]}" (code: ${parsedNormalized.charCodeAt(i)})`);
        log(`        Canvas char: "${canvasNormalized[i]}" (code: ${canvasNormalized.charCodeAt(i)})`);
        log(`        Context parsed: "...${parsedNormalized.substring(Math.max(0, i - 20), i + 20)}..."`);
        log(`        Context canvas: "...${canvasNormalized.substring(Math.max(0, i - 20), i + 20)}..."`);
        break;
      }
    }
    if (parsedNormalized.length !== canvasNormalized.length) {
      log(`      Length difference: parsed=${parsedNormalized.length}, canvas=${canvasNormalized.length}`);
    }
    changedFields.push("body");
  } else {
    log(`      Body unchanged (normalized comparison passed)`);
  }
  if (changedFields.length > 0) {
    log(`      Result: UPDATE - Changed fields: [${changedFields.join(", ")}]`);
    return {
      hasChanges: true,
      changedFields,
      action: "update"
    };
  }
  log(`      Result: SKIP - No changes detected`);
  return {
    hasChanges: false,
    changedFields: [],
    action: "skip"
  };
}
function compareAssignment(parsed, canvas) {
  var _a, _b;
  if (!canvas) {
    return {
      hasChanges: true,
      changedFields: [],
      action: "create"
    };
  }
  const changedFields = [];
  if (parsed.title !== canvas.name) {
    changedFields.push("title");
  }
  const parsedDescHtml = markdownToSimpleHtml(parsed.description);
  const canvasDescHtml = canvas.description || "";
  const parsedDescNorm = normalizeHtml(parsedDescHtml);
  const canvasDescNorm = normalizeHtml(canvasDescHtml);
  if (parsedDescNorm !== canvasDescNorm) {
    log(`      Description changed`);
    log(`      Parsed desc (raw, first 200): "${parsed.description.substring(0, 200)}..."`);
    log(`      Canvas desc (raw, first 200): "${canvasDescHtml.substring(0, 200)}..."`);
    log(`      Parsed (normalized, first 200): "${parsedDescNorm.substring(0, 200)}..."`);
    log(`      Canvas (normalized, first 200): "${canvasDescNorm.substring(0, 200)}..."`);
    for (let i = 0; i < Math.min(parsedDescNorm.length, canvasDescNorm.length); i++) {
      if (parsedDescNorm[i] !== canvasDescNorm[i]) {
        log(`      First difference at position ${i}:`);
        log(`        Parsed char: "${parsedDescNorm[i]}" (code: ${parsedDescNorm.charCodeAt(i)})`);
        log(`        Canvas char: "${canvasDescNorm[i]}" (code: ${canvasDescNorm.charCodeAt(i)})`);
        log(`        Context parsed: "...${parsedDescNorm.substring(Math.max(0, i - 20), i + 20)}..."`);
        log(`        Context canvas: "...${canvasDescNorm.substring(Math.max(0, i - 20), i + 20)}..."`);
        break;
      }
    }
    if (parsedDescNorm.length !== canvasDescNorm.length) {
      log(`      Length difference: parsed=${parsedDescNorm.length}, canvas=${canvasDescNorm.length}`);
    }
    changedFields.push("description");
  }
  const parsedPoints = (_a = parsed.pointsPossible) != null ? _a : null;
  const canvasPoints = (_b = canvas.points_possible) != null ? _b : null;
  if (parsedPoints !== canvasPoints) {
    changedFields.push("points_possible");
  }
  const parsedDue = parsed.dueAt ? new Date(parsed.dueAt).toISOString() : null;
  const canvasDue = canvas.due_at ? new Date(canvas.due_at).toISOString() : null;
  if (parsedDue !== canvasDue) {
    changedFields.push("due_at");
  }
  if (parsed.gradingType && parsed.gradingType !== canvas.grading_type) {
    changedFields.push("grading_type");
  }
  if (changedFields.length > 0) {
    return {
      hasChanges: true,
      changedFields,
      action: "update"
    };
  }
  return {
    hasChanges: false,
    changedFields: [],
    action: "skip"
  };
}
function compareDiscussion(parsed, canvas) {
  log(`      Comparing discussion: "${parsed.title}"`);
  if (!canvas) {
    log(`      No Canvas data found - marking as CREATE`);
    return {
      hasChanges: true,
      changedFields: [],
      action: "create"
    };
  }
  const changedFields = [];
  if (parsed.title !== canvas.title) {
    log(`      Title changed: "${parsed.title}" !== "${canvas.title}"`);
    changedFields.push("title");
  }
  const parsedMsgHtml = markdownToSimpleHtml(parsed.message);
  const canvasMsgHtml = canvas.message || "";
  const match = compareHtmlContent(parsedMsgHtml, canvasMsgHtml);
  if (!match) {
    log(`      Message changed (normalized comparison failed)`);
    log(`      Parsed (normalized): "${normalizeHtml(parsedMsgHtml).substring(0, 100)}..."`);
    log(`      Canvas (normalized): "${normalizeHtml(canvasMsgHtml).substring(0, 100)}..."`);
    changedFields.push("message");
  }
  if (parsed.requireInitialPost !== canvas.require_initial_post) {
    log(`      require_initial_post changed: ${parsed.requireInitialPost} !== ${canvas.require_initial_post}`);
    changedFields.push("require_initial_post");
  }
  const canvasThreaded = canvas.discussion_type === "threaded";
  if (parsed.threaded !== canvasThreaded) {
    log(`      threaded changed: ${parsed.threaded} !== ${canvasThreaded}`);
    changedFields.push("threaded");
  }
  const canvasGraded = canvas.assignment !== void 0;
  if (parsed.graded !== canvasGraded) {
    log(`      graded changed: ${parsed.graded} !== ${canvasGraded}`);
    changedFields.push("graded");
  }
  if (parsed.graded && canvas.assignment) {
    if (parsed.pointsPossible !== canvas.assignment.points_possible) {
      log(`      points changed: ${parsed.pointsPossible} !== ${canvas.assignment.points_possible}`);
      changedFields.push("points");
    }
    const parsedDue = parsed.dueAt ? new Date(parsed.dueAt).toISOString() : null;
    const canvasDue = canvas.assignment.due_at ? new Date(canvas.assignment.due_at).toISOString() : null;
    if (parsedDue !== canvasDue) {
      log(`      due_at changed: ${parsedDue} !== ${canvasDue}`);
      changedFields.push("due_at");
    }
  }
  if (changedFields.length > 0) {
    log(`      Result: UPDATE - Changed fields: [${changedFields.join(", ")}]`);
    return {
      hasChanges: true,
      changedFields,
      action: "update"
    };
  }
  log(`      Result: SKIP - No changes detected`);
  return {
    hasChanges: false,
    changedFields: [],
    action: "skip"
  };
}

// src/upload/uploader.ts
var CourseUploader = class {
  constructor(baseUrl, token, courseId, debug = false) {
    this.debug = false;
    this.apiClient = new CanvasApiClient(baseUrl, token);
    this.apiClientWrite = new CanvasApiClientWrite(baseUrl, token, courseId);
    this.linkResolver = new LinkResolver();
    this.courseId = courseId;
    this.debug = debug;
    if (debug) {
      setComparatorDebug(true);
    }
  }
  /**
   * Enable debug logging
   */
  setDebug(enabled) {
    this.debug = enabled;
    setComparatorDebug(enabled);
  }
  log(...args) {
    if (this.debug) {
      console.log("[CourseUploader]", ...args);
    }
  }
  /**
   * Generate preview of changes (dry-run)
   */
  async generatePreview(modules) {
    const preview = [];
    this.log("=== STARTING PREVIEW GENERATION ===");
    this.log(`Total modules to process: ${modules.length}`);
    this.linkResolver.clear();
    await this.registerAllCourseFiles();
    const canvasData = await this.fetchCanvasData(modules);
    this.log(`Fetched Canvas data entries: ${canvasData.size}`);
    for (const module2 of modules) {
      if (module2.title === "Course Files") {
        this.log(`
--- Skipping "Course Files" section (not a module) ---`);
        continue;
      }
      this.log(`
--- Processing module: "${module2.title}" ---`);
      this.log(`Module Canvas ID: ${module2.canvasModuleId || "NONE (will create)"}`);
      const previewItem = await this.generateModulePreview(module2, canvasData);
      preview.push(previewItem);
    }
    this.log("\n=== PREVIEW GENERATION COMPLETE ===");
    return preview;
  }
  /**
   * Generate preview for a single module
   */
  async generateModulePreview(module2, canvasData) {
    const canvasModule = module2.canvasModuleId ? canvasData.get(`module_${module2.canvasModuleId}`) : void 0;
    const moduleComparison = compareModule(module2, canvasModule);
    const itemPreviews = [];
    for (const item of module2.items) {
      const itemPreview = await this.generateItemPreview(item, canvasData);
      itemPreviews.push(itemPreview);
    }
    return {
      moduleTitle: module2.title,
      modulAction: moduleComparison.action,
      moduleChangedFields: moduleComparison.changedFields,
      items: itemPreviews
    };
  }
  /**
   * Generate preview for a single item
   */
  async generateItemPreview(item, canvasData) {
    var _a, _b, _c, _d, _e, _f;
    let comparison;
    let metadata = {};
    this.log(`  Processing item [${item.type}]: "${item.title}"`);
    switch (item.type) {
      case "page": {
        const page = item;
        this.log(`    Canvas Page ID: ${page.canvasPageId || "NONE"}`);
        const canvasPage = page.canvasPageId ? canvasData.get(`page_${page.canvasPageId}`) : void 0;
        this.log(`    Canvas data found: ${!!canvasPage}`);
        if (canvasPage) {
          this.log(`    Canvas title: "${canvasPage.title}"`);
          this.log(`    Parsed title: "${page.title}"`);
          this.log(`    Canvas body length: ${((_a = canvasPage.body) == null ? void 0 : _a.length) || 0}`);
          this.log(`    Parsed body length: ${((_b = page.body) == null ? void 0 : _b.length) || 0}`);
        }
        comparison = comparePage(page, canvasPage);
        this.log(`    Action: ${comparison.action}, Changed fields: [${comparison.changedFields.join(", ")}]`);
        break;
      }
      case "assignment": {
        const assignment = item;
        this.log(`    Canvas Assignment ID: ${assignment.canvasAssignmentId || "NONE"}`);
        const canvasAssignment = assignment.canvasAssignmentId ? canvasData.get(`assignment_${assignment.canvasAssignmentId}`) : void 0;
        this.log(`    Canvas data found: ${!!canvasAssignment}`);
        if (canvasAssignment) {
          this.log(`    Canvas name: "${canvasAssignment.name}"`);
          this.log(`    Parsed title: "${assignment.title}"`);
          this.log(`    Canvas description length: ${((_c = canvasAssignment.description) == null ? void 0 : _c.length) || 0}`);
          this.log(`    Parsed description length: ${((_d = assignment.description) == null ? void 0 : _d.length) || 0}`);
          this.log(`    Canvas points: ${canvasAssignment.points_possible}`);
          this.log(`    Parsed points: ${assignment.pointsPossible}`);
        }
        comparison = compareAssignment(assignment, canvasAssignment);
        this.log(`    Action: ${comparison.action}, Changed fields: [${comparison.changedFields.join(", ")}]`);
        if (assignment.pointsPossible !== void 0) {
          metadata.points = assignment.pointsPossible;
        }
        if (assignment.dueAt) {
          metadata.due = assignment.dueAt;
        }
        if (assignment.gradingType) {
          metadata.grading_type = assignment.gradingType;
        }
        break;
      }
      case "discussion": {
        const discussion = item;
        this.log(`    Canvas Discussion ID: ${discussion.canvasDiscussionId || "NONE"}`);
        const canvasDiscussion = discussion.canvasDiscussionId ? canvasData.get(`discussion_${discussion.canvasDiscussionId}`) : void 0;
        this.log(`    Canvas data found: ${!!canvasDiscussion}`);
        if (canvasDiscussion) {
          this.log(`    Canvas title: "${canvasDiscussion.title}"`);
          this.log(`    Parsed title: "${discussion.title}"`);
          this.log(`    Canvas message length: ${((_e = canvasDiscussion.message) == null ? void 0 : _e.length) || 0}`);
          this.log(`    Parsed message length: ${((_f = discussion.message) == null ? void 0 : _f.length) || 0}`);
          this.log(`    Canvas require_initial_post: ${canvasDiscussion.require_initial_post}`);
          this.log(`    Parsed require_initial_post: ${discussion.requireInitialPost}`);
          this.log(`    Canvas threaded: ${canvasDiscussion.discussion_type === "threaded"}`);
          this.log(`    Parsed threaded: ${discussion.threaded}`);
          this.log(`    Canvas graded: ${canvasDiscussion.assignment !== void 0}`);
          this.log(`    Parsed graded: ${discussion.graded}`);
        }
        comparison = compareDiscussion(discussion, canvasDiscussion);
        this.log(`    Action: ${comparison.action}, Changed fields: [${comparison.changedFields.join(", ")}]`);
        metadata.require_initial_post = discussion.requireInitialPost;
        if (discussion.graded && discussion.pointsPossible !== void 0) {
          metadata.points = discussion.pointsPossible;
        }
        break;
      }
      case "header":
      case "link":
      case "file":
        this.log(`    Canvas Module Item ID: ${item.canvasModuleItemId || "NONE"}`);
        comparison = {
          hasChanges: item.canvasModuleItemId === void 0,
          changedFields: [],
          action: item.canvasModuleItemId === void 0 ? "create" : "skip"
        };
        this.log(`    Action: ${comparison.action}`);
        break;
    }
    return {
      type: item.type,
      title: item.title,
      action: comparison.action,
      changedFields: comparison.changedFields,
      metadata: Object.keys(metadata).length > 0 ? metadata : void 0
    };
  }
  /**
   * Upload course content (three-phase workflow)
   */
  async upload(modules, dryRun = false) {
    const stats = {
      itemsCreated: 0,
      itemsUpdated: 0,
      itemsSkipped: 0,
      errors: []
    };
    if (dryRun) {
      return stats;
    }
    this.linkResolver.clear();
    await this.registerAllCourseFiles();
    const canvasData = await this.fetchCanvasData(modules);
    const itemsNeedingLinks = [];
    for (const module2 of modules) {
      await this.uploadModule(module2, canvasData, stats, itemsNeedingLinks);
    }
    await this.resolveLinks(itemsNeedingLinks, stats);
    await this.updateModulePositions(modules, stats);
    return stats;
  }
  /**
   * Fetch existing Canvas data for comparison
   */
  async fetchCanvasData(modules) {
    const data = /* @__PURE__ */ new Map();
    try {
      const canvasModules = await this.apiClient.getModules(this.courseId);
      for (const module2 of canvasModules) {
        data.set(`module_${module2.id}`, module2);
      }
      for (const module2 of modules) {
        for (const item of module2.items) {
          try {
            if (item.type === "page" && item.canvasPageId) {
              const page = await this.apiClient.getPage(this.courseId, item.canvasPageId);
              data.set(`page_${page.url}`, page);
            } else if (item.type === "assignment" && item.canvasAssignmentId) {
              const assignment = await this.apiClient.getAssignment(
                this.courseId,
                String(item.canvasAssignmentId)
              );
              data.set(`assignment_${assignment.id}`, assignment);
            } else if (item.type === "discussion" && item.canvasDiscussionId) {
              const discussion = await this.apiClient.getDiscussion(
                this.courseId,
                String(item.canvasDiscussionId)
              );
              data.set(`discussion_${discussion.id}`, discussion);
            }
          } catch (error) {
            console.warn(`Failed to fetch Canvas data for item: ${item.title}`, error);
          }
        }
      }
      for (const module2 of modules) {
        for (const item of module2.items) {
          if (item.type === "file" && item.canvasFileId) {
            try {
              const file = await this.apiClient.getFile(
                String(item.canvasFileId)
              );
              data.set(`file_${file.id}`, file);
            } catch (error) {
              console.warn(`Failed to fetch Canvas data for file: ${item.title}`, error);
            }
          }
        }
      }
    } catch (error) {
      console.warn("Failed to fetch Canvas data, proceeding with upload", error);
    }
    return data;
  }
  /**
   * Pre-register all course files for link resolution
   */
  async registerAllCourseFiles() {
    try {
      const folders = await this.apiClient.getCourseFolders(this.courseId);
      for (const folder of folders) {
        const files = await this.apiClient.getFolderFiles(folder.id);
        for (const file of files) {
          const baseUrl = this.apiClientWrite["_baseUrl"];
          let fileUrl = `${baseUrl}/courses/${this.courseId}/files/${file.id}`;
          const verifierMatch = file.url.match(/[?&]verifier=([^&]+)/);
          if (verifierMatch) {
            fileUrl += `?verifier=${verifierMatch[1]}`;
          }
          this.linkResolver.register("file", file.display_name, fileUrl);
          if (file.filename !== file.display_name) {
            this.linkResolver.register("file", file.filename, fileUrl);
          }
        }
      }
    } catch (error) {
      console.warn("Failed to fetch course files for link resolution", error);
    }
  }
  /**
   * Upload a single module and its items
   */
  async uploadModule(module2, canvasData, stats, itemsNeedingLinks) {
    if (module2.title === "Course Files") {
      for (const item of module2.items) {
        if (item.type === "file") {
          await this.uploadFile(item, canvasData, stats);
        }
      }
      return 0;
    }
    let moduleId = module2.canvasModuleId;
    try {
      const canvasModule = moduleId ? canvasData.get(`module_${moduleId}`) : void 0;
      const moduleComparison = compareModule(module2, canvasModule);
      if (moduleComparison.action === "create") {
        const created = await this.apiClientWrite.createModule({ name: module2.title });
        moduleId = created.id;
        stats.itemsCreated++;
      } else if (moduleComparison.action === "update") {
        await this.apiClientWrite.updateModule(moduleId, { name: module2.title });
        stats.itemsUpdated++;
      } else {
        stats.itemsSkipped++;
      }
      for (const item of module2.items) {
        await this.uploadItem(item, moduleId, canvasData, stats, itemsNeedingLinks);
      }
    } catch (error) {
      stats.errors.push({
        itemType: "module",
        itemTitle: module2.title,
        error: error.message || String(error)
      });
    }
    return moduleId;
  }
  /**
   * Upload a single item
   */
  async uploadItem(item, moduleId, canvasData, stats, itemsNeedingLinks) {
    try {
      switch (item.type) {
        case "page":
          await this.uploadPage(item, moduleId, canvasData, stats, itemsNeedingLinks);
          break;
        case "assignment":
          await this.uploadAssignment(item, moduleId, canvasData, stats, itemsNeedingLinks);
          break;
        case "discussion":
          await this.uploadDiscussion(item, moduleId, canvasData, stats, itemsNeedingLinks);
          break;
        case "header":
          await this.uploadHeader(item, moduleId, stats);
          break;
        case "link":
          await this.uploadLink(item, moduleId, stats);
          break;
        case "file":
          await this.uploadFile(item, canvasData, stats);
          break;
      }
    } catch (error) {
      stats.errors.push({
        itemType: item.type,
        itemTitle: item.title,
        error: error.message || String(error)
      });
    }
  }
  /**
   * Upload a page
   */
  async uploadPage(page, moduleId, canvasData, stats, itemsNeedingLinks) {
    const canvasPage = page.canvasPageId ? canvasData.get(`page_${page.canvasPageId}`) : void 0;
    const comparison = comparePage(page, canvasPage);
    if (comparison.action === "create") {
      const created = await this.apiClientWrite.createPage({
        title: page.title,
        body: markdownToSimpleHtml(page.body),
        published: true
      });
      stats.itemsCreated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/pages/${created.url}`;
      this.linkResolver.register("page", page.title, url);
      if (this.linkResolver.hasInternalLinks(page.body)) {
        itemsNeedingLinks.push({ type: "page", id: created.url, content: page.body });
      }
      if (!page.canvasModuleItemId) {
        await this.apiClientWrite.createModuleItem(moduleId, {
          title: page.title,
          type: "Page",
          page_url: created.url
        });
      }
    } else if (comparison.action === "update") {
      await this.apiClientWrite.updatePage(page.canvasPageId, {
        title: page.title,
        body: markdownToSimpleHtml(page.body)
      });
      stats.itemsUpdated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/pages/${page.canvasPageId}`;
      this.linkResolver.register("page", page.title, url);
      if (this.linkResolver.hasInternalLinks(page.body)) {
        itemsNeedingLinks.push({ type: "page", id: page.canvasPageId, content: page.body });
      }
    } else {
      stats.itemsSkipped++;
      if (page.canvasPageId) {
        const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/pages/${page.canvasPageId}`;
        this.linkResolver.register("page", page.title, url);
      }
    }
  }
  /**
   * Upload an assignment
   */
  async uploadAssignment(assignment, moduleId, canvasData, stats, itemsNeedingLinks) {
    const canvasAssignment = assignment.canvasAssignmentId ? canvasData.get(`assignment_${assignment.canvasAssignmentId}`) : void 0;
    const comparison = compareAssignment(assignment, canvasAssignment);
    if (comparison.action === "create") {
      const created = await this.apiClientWrite.createAssignment({
        name: assignment.title,
        description: markdownToSimpleHtml(assignment.description),
        points_possible: assignment.pointsPossible,
        due_at: assignment.dueAt,
        grading_type: assignment.gradingType,
        submission_types: assignment.submissionTypes,
        published: true
      });
      stats.itemsCreated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/assignments/${created.id}`;
      this.linkResolver.register("assignment", assignment.title, url);
      if (this.linkResolver.hasInternalLinks(assignment.description)) {
        itemsNeedingLinks.push({ type: "assignment", id: created.id, content: assignment.description });
      }
      if (!assignment.canvasModuleItemId) {
        await this.apiClientWrite.createModuleItem(moduleId, {
          title: assignment.title,
          type: "Assignment",
          content_id: created.id
        });
      }
    } else if (comparison.action === "update") {
      await this.apiClientWrite.updateAssignment(assignment.canvasAssignmentId, {
        name: assignment.title,
        description: markdownToSimpleHtml(assignment.description),
        points_possible: assignment.pointsPossible,
        due_at: assignment.dueAt,
        grading_type: assignment.gradingType
        // Note: Cannot update submission_types (Canvas limitation)
      });
      stats.itemsUpdated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/assignments/${assignment.canvasAssignmentId}`;
      this.linkResolver.register("assignment", assignment.title, url);
      if (this.linkResolver.hasInternalLinks(assignment.description)) {
        itemsNeedingLinks.push({ type: "assignment", id: assignment.canvasAssignmentId, content: assignment.description });
      }
    } else {
      stats.itemsSkipped++;
      if (assignment.canvasAssignmentId) {
        const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/assignments/${assignment.canvasAssignmentId}`;
        this.linkResolver.register("assignment", assignment.title, url);
      }
    }
  }
  /**
   * Upload a discussion
   */
  async uploadDiscussion(discussion, moduleId, canvasData, stats, itemsNeedingLinks) {
    const canvasDiscussion = discussion.canvasDiscussionId ? canvasData.get(`discussion_${discussion.canvasDiscussionId}`) : void 0;
    const comparison = compareDiscussion(discussion, canvasDiscussion);
    if (comparison.action === "create") {
      const params = {
        title: discussion.title,
        message: markdownToSimpleHtml(discussion.message),
        discussion_type: discussion.threaded ? "threaded" : "side_comment",
        require_initial_post: discussion.requireInitialPost,
        published: true
      };
      if (discussion.graded && discussion.pointsPossible !== void 0) {
        params.assignment = {
          points_possible: discussion.pointsPossible,
          due_at: discussion.dueAt
        };
      }
      const created = await this.apiClientWrite.createDiscussion(params);
      stats.itemsCreated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/discussion_topics/${created.id}`;
      this.linkResolver.register("discussion", discussion.title, url);
      if (this.linkResolver.hasInternalLinks(discussion.message)) {
        itemsNeedingLinks.push({ type: "discussion", id: created.id, content: discussion.message });
      }
      if (!discussion.canvasModuleItemId) {
        await this.apiClientWrite.createModuleItem(moduleId, {
          title: discussion.title,
          type: "Discussion",
          content_id: created.id
        });
      }
    } else if (comparison.action === "update") {
      const params = {
        title: discussion.title,
        message: markdownToSimpleHtml(discussion.message),
        discussion_type: discussion.threaded ? "threaded" : "side_comment",
        require_initial_post: discussion.requireInitialPost
      };
      if (discussion.graded && discussion.pointsPossible !== void 0) {
        params.assignment = {
          points_possible: discussion.pointsPossible,
          due_at: discussion.dueAt
        };
      }
      await this.apiClientWrite.updateDiscussion(discussion.canvasDiscussionId, params);
      stats.itemsUpdated++;
      const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/discussion_topics/${discussion.canvasDiscussionId}`;
      this.linkResolver.register("discussion", discussion.title, url);
      if (this.linkResolver.hasInternalLinks(discussion.message)) {
        itemsNeedingLinks.push({ type: "discussion", id: discussion.canvasDiscussionId, content: discussion.message });
      }
    } else {
      stats.itemsSkipped++;
      if (discussion.canvasDiscussionId) {
        const url = `${this.apiClientWrite["_baseUrl"]}/courses/${this.courseId}/discussion_topics/${discussion.canvasDiscussionId}`;
        this.linkResolver.register("discussion", discussion.title, url);
      }
    }
  }
  /**
   * Upload a header (SubHeader)
   */
  async uploadHeader(header, moduleId, stats) {
    if (!header.canvasModuleItemId) {
      await this.apiClientWrite.createModuleItem(moduleId, {
        title: header.title,
        type: "SubHeader"
      });
      stats.itemsCreated++;
    } else {
      stats.itemsSkipped++;
    }
  }
  /**
   * Upload a link (ExternalUrl)
   */
  async uploadLink(link, moduleId, stats) {
    if (!link.canvasModuleItemId) {
      await this.apiClientWrite.createModuleItem(moduleId, {
        title: link.title,
        type: "ExternalUrl",
        external_url: link.url
      });
      stats.itemsCreated++;
    } else {
      stats.itemsSkipped++;
    }
  }
  /**
   * Register a file for link resolution (files cannot be uploaded via API)
   */
  async uploadFile(file, canvasData, stats) {
    stats.itemsSkipped++;
    if (file.canvasFileId) {
      const canvasFile = canvasData.get(`file_${file.canvasFileId}`);
      if (canvasFile) {
        let fileUrl;
        if (canvasFile.preview_url) {
          fileUrl = canvasFile.preview_url;
        } else {
          const baseUrl = this.apiClientWrite["_baseUrl"];
          const verifierMatch = canvasFile.url.match(/[?&]verifier=([^&]+)/);
          const verifier = verifierMatch ? verifierMatch[1] : null;
          fileUrl = `${baseUrl}/courses/${this.courseId}/files/${canvasFile.id}`;
          if (verifier) {
            fileUrl += `?verifier=${verifier}`;
          }
        }
        this.linkResolver.register("file", canvasFile.display_name, fileUrl);
        if (canvasFile.filename !== canvasFile.display_name) {
          this.linkResolver.register("file", canvasFile.filename, fileUrl);
        }
      } else {
        console.warn(
          `File "${file.title}" has Canvas ID ${file.canvasFileId} but was not found in Canvas. Links to this file will not be resolved.`
        );
      }
    }
  }
  /**
   * Phase 2: Resolve internal links
   */
  async resolveLinks(items, stats) {
    for (const item of items) {
      try {
        const { resolved, hasLinks } = this.linkResolver.resolve(item.content);
        if (hasLinks) {
          const resolvedHtml = markdownToSimpleHtml(resolved);
          if (item.type === "page") {
            await this.apiClientWrite.updatePage(item.id, { body: resolvedHtml });
          } else if (item.type === "assignment") {
            await this.apiClientWrite.updateAssignment(item.id, { description: resolvedHtml });
          } else if (item.type === "discussion") {
            await this.apiClientWrite.updateDiscussion(item.id, { message: resolvedHtml });
          }
        }
      } catch (error) {
        stats.errors.push({
          itemType: item.type,
          itemTitle: `Link resolution for ${item.type} ${item.id}`,
          error: error.message || String(error)
        });
      }
    }
  }
  /**
   * Phase 3: Update module positions (placeholder)
   */
  async updateModulePositions(modules, stats) {
  }
};

// src/utils/frontmatter-utils.ts
function extractCanvasCourseId(content) {
  const lines = content.split("\n");
  let inFrontmatter = false;
  for (const line of lines) {
    if (line.trim() === "---") {
      if (!inFrontmatter) {
        inFrontmatter = true;
        continue;
      } else {
        break;
      }
    }
    if (inFrontmatter) {
      const match = line.match(/^canvas_course_id:\s*(.+)$/);
      if (match) {
        return match[1].trim();
      }
    }
  }
  return null;
}

// src/modals/confirmation-modal.ts
var import_obsidian13 = require("obsidian");
var ConfirmationModal = class extends import_obsidian13.Modal {
  constructor(app, title, message, confirmText, onConfirm, onCancel) {
    super(app);
    this.titleEl.setText(title);
    this.message = message;
    this.confirmText = confirmText;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel || (() => {
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const messageEl = contentEl.createEl("p", {
      text: this.message,
      cls: "mod-warning"
    });
    messageEl.style.marginBottom = "20px";
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const confirmButton = buttonContainer.createEl("button", {
      text: this.confirmText,
      cls: "mod-cta"
    });
    confirmButton.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
      this.onCancel();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var CanvaslmsHelperPlugin = class extends import_obsidian14.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "download-course",
      name: "Download course",
      callback: async () => {
        await this.downloadCourse();
      }
    });
    this.addCommand({
      id: "upload-course",
      name: "Upload to Canvas",
      callback: async () => {
        await this.uploadCourse();
      }
    });
    this.addCommand({
      id: "canvas-insert-module",
      name: "Insert Canvas Module",
      editorCallback: async (editor, view) => {
        await this.insertModule(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-header",
      name: "Insert Canvas Header",
      editorCallback: async (editor, view) => {
        await this.insertHeader(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-page",
      name: "Insert Canvas Page",
      editorCallback: async (editor, view) => {
        await this.insertPage(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-link",
      name: "Insert Canvas Link",
      editorCallback: async (editor, view) => {
        await this.insertLink(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-file",
      name: "Insert Canvas File",
      editorCallback: async (editor, view) => {
        await this.insertFile(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-assignment",
      name: "Insert Canvas Assignment",
      editorCallback: async (editor, view) => {
        await this.insertAssignment(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-discussion",
      name: "Insert Canvas Discussion",
      editorCallback: async (editor, view) => {
        await this.insertDiscussion(editor);
      }
    });
    this.addCommand({
      id: "canvas-insert-internal-link",
      name: "Insert Canvas Internal Link",
      editorCallback: async (editor, view) => {
        await this.insertInternalLink(editor);
      }
    });
    this.addCommand({
      id: "canvas-add-content",
      name: "Add Canvas Content",
      editorCallback: async (editor, view) => {
        await this.addContent(editor);
      }
    });
  }
  /**
   * Download course (smart command that detects re-download vs. new download)
   */
  async downloadCourse() {
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      const content = await this.app.vault.read(activeFile);
      const courseId = extractCanvasCourseId(content);
      if (courseId) {
        await this.redownloadCourse(courseId, activeFile);
        return;
      }
    }
    await this.downloadCourseNew();
  }
  /**
   * Re-download an existing Canvas course file
   */
  async redownloadCourse(courseId, file) {
    if (!this.settings.canvasUrl || !this.settings.canvasToken) {
      new import_obsidian14.Notice("Please configure Canvas URL and token in settings");
      return;
    }
    try {
      const client = new CanvasApiClient(this.settings.canvasUrl, this.settings.canvasToken);
      const course = await client.getCourse(courseId);
      const confirmed = await new Promise((resolve) => {
        new ConfirmationModal(
          this.app,
          "Re-download course from Canvas?",
          `Course: ${course.name} (ID: ${courseId})

This will replace the current file with fresh data from Canvas.`,
          "Re-download",
          () => resolve(true),
          () => resolve(false)
        ).open();
      });
      if (!confirmed) return;
      const notice = new import_obsidian14.Notice("Downloading course from Canvas...", 0);
      try {
        const courseData = await this.fetchCourseData(client, courseId);
        const formatter = new CanvasCourseFormatter();
        const markdown = formatter.formatCourse(
          courseId,
          this.settings.canvasUrl,
          courseData.modules,
          courseData.itemsData
        );
        await this.app.vault.modify(file, markdown);
        notice.hide();
        new import_obsidian14.Notice("Course re-downloaded successfully!");
      } catch (error) {
        notice.hide();
        throw error;
      }
    } catch (error) {
      new import_obsidian14.Notice(`Error: ${error.message}`);
      console.error("Canvas re-download error:", error);
    }
  }
  /**
   * Main download course workflow (new course)
   */
  async downloadCourseNew() {
    if (!this.settings.canvasUrl || !this.settings.canvasToken) {
      new import_obsidian14.Notice("Please configure Canvas URL and token in settings");
      return;
    }
    const courseId = await this.promptForCourseId();
    if (!courseId) return;
    const notice = new import_obsidian14.Notice("Downloading course from Canvas...", 0);
    try {
      const client = new CanvasApiClient(this.settings.canvasUrl, this.settings.canvasToken);
      const courseData = await this.fetchCourseData(client, courseId);
      const formatter = new CanvasCourseFormatter();
      const markdown = formatter.formatCourse(
        courseId,
        this.settings.canvasUrl,
        courseData.modules,
        courseData.itemsData
      );
      notice.hide();
      const folderPath = await this.promptForFolder();
      if (folderPath === null) return;
      await this.saveCourseFile(courseId, courseData.course.name, markdown, folderPath);
      new import_obsidian14.Notice("Course downloaded successfully!");
    } catch (error) {
      notice.hide();
      new import_obsidian14.Notice(`Error: ${error.message}`);
      console.error("Canvas download error:", error);
    }
  }
  /**
   * Prompt user for course ID via modal
   */
  async promptForCourseId() {
    return new Promise((resolve) => {
      const modal = new CourseInputModal(this.app, (courseId) => {
        resolve(courseId);
      });
      modal.open();
    });
  }
  /**
   * Prompt user for folder location via modal
   * Returns folder path or null if cancelled
   */
  async promptForFolder() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    const defaultFolder = ((_a = activeFile == null ? void 0 : activeFile.parent) == null ? void 0 : _a.path) || "";
    return new Promise((resolve) => {
      const modal = new FolderPickerModal(this.app, defaultFolder, (folderPath) => {
        resolve(folderPath);
      });
      modal.open();
    });
  }
  /**
   * Fetch all course data from Canvas
   */
  async fetchCourseData(client, courseId) {
    const course = await client.getCourse(courseId);
    const modules = await client.getModules(courseId);
    const itemsData = /* @__PURE__ */ new Map();
    for (const module2 of modules) {
      const items = await client.getModuleItems(courseId, module2.id.toString());
      itemsData.set(`module_${module2.id}`, items);
      for (const item of items) {
        await this.fetchItemDetails(client, courseId, item, itemsData);
      }
    }
    const allFiles = await this.fetchAllCourseFiles(client, courseId);
    itemsData.set("course_files", allFiles);
    return { course, modules, itemsData };
  }
  /**
   * Fetch detailed content for a module item based on its type
   */
  async fetchItemDetails(client, courseId, item, itemsData) {
    try {
      switch (item.type) {
        case "Page":
          if (item.page_url) {
            const page = await client.getPage(courseId, item.page_url);
            itemsData.set(`page_${item.page_url}`, page);
          }
          break;
        case "Assignment":
          if (item.content_id) {
            const assignment = await client.getAssignment(courseId, item.content_id.toString());
            itemsData.set(`assignment_${item.content_id}`, assignment);
          }
          break;
        case "Discussion":
          if (item.content_id) {
            const discussion = await client.getDiscussion(courseId, item.content_id.toString());
            itemsData.set(`discussion_${item.content_id}`, discussion);
          }
          break;
        case "File":
          if (item.content_id) {
            const file = await client.getFile(item.content_id.toString());
            itemsData.set(`file_${item.content_id}`, file);
          }
          break;
      }
    } catch (error) {
      console.warn(`Failed to fetch details for ${item.type} "${item.title}":`, error);
    }
  }
  /**
   * Fetch all files in a course, regardless of whether they're in modules
   */
  async fetchAllCourseFiles(client, courseId) {
    try {
      const folders = await client.getCourseFolders(courseId);
      const allFiles = [];
      for (const folder of folders) {
        try {
          const files = await client.getFolderFiles(folder.id);
          allFiles.push(...files);
        } catch (error) {
          console.warn(`Failed to fetch files from folder "${folder.name}":`, error);
        }
      }
      return allFiles;
    } catch (error) {
      console.warn("Failed to fetch course files:", error);
      return [];
    }
  }
  /**
   * Save course markdown to vault
   */
  async saveCourseFile(courseId, courseName, markdown, folderPath) {
    const safeName = courseName.replace(/[^a-zA-Z0-9-_ ]/g, "").trim();
    const filename = `Canvas Course ${courseId} - ${safeName}.md`;
    const fullPath = folderPath ? `${folderPath}/${filename}` : filename;
    const normalizedPath = (0, import_obsidian14.normalizePath)(fullPath);
    const existingFile = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFile instanceof import_obsidian14.TFile) {
      await this.app.vault.modify(existingFile, markdown);
    } else {
      await this.app.vault.create(normalizedPath, markdown);
    }
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian14.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    }
  }
  /**
   * Main upload course workflow
   */
  async uploadCourse() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian14.Notice("No active file. Please open a Canvas course file.");
      return;
    }
    if (!this.settings.canvasUrl || !this.settings.canvasToken) {
      new import_obsidian14.Notice("Please configure Canvas URL and token in settings");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const parser = new MarkdownParser(content);
    const { frontmatter, modules } = parser.parse();
    if (!frontmatter.canvas_course_id) {
      new import_obsidian14.Notice("Error: Missing canvas_course_id in frontmatter");
      return;
    }
    if (!frontmatter.canvas_url) {
      new import_obsidian14.Notice("Error: Missing canvas_url in frontmatter");
      return;
    }
    const uploader = new CourseUploader(
      this.settings.canvasUrl,
      this.settings.canvasToken,
      frontmatter.canvas_course_id
    );
    const previewNotice = new import_obsidian14.Notice("Analyzing changes...", 0);
    try {
      const preview = await uploader.generatePreview(modules);
      previewNotice.hide();
      new UploadPreviewModal(this.app, preview, async () => {
        const uploadNotice = new import_obsidian14.Notice("Uploading to Canvas...", 0);
        try {
          const stats = await uploader.upload(modules, false);
          uploadNotice.hide();
          if (stats.errors.length > 0) {
            new import_obsidian14.Notice(
              `Upload complete with errors: ${stats.itemsCreated} created, ${stats.itemsUpdated} updated, ${stats.itemsSkipped} skipped, ${stats.errors.length} errors (see console)`,
              1e4
            );
            console.error("Upload errors:", stats.errors);
          } else {
            new import_obsidian14.Notice(
              `Upload complete: ${stats.itemsCreated} created, ${stats.itemsUpdated} updated, ${stats.itemsSkipped} skipped`,
              5e3
            );
          }
        } catch (error) {
          uploadNotice.hide();
          new import_obsidian14.Notice(`Upload error: ${error.message}`);
          console.error("Canvas upload error:", error);
        }
      }).open();
    } catch (error) {
      previewNotice.hide();
      new import_obsidian14.Notice(`Error generating preview: ${error.message}`);
      console.error("Canvas preview error:", error);
    }
  }
  async onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Template insertion commands
   */
  async insertModule(editor) {
    const modal = new SimpleTextModal(
      this.app,
      "Insert Canvas Module",
      "Module title",
      "Enter module title (e.g., Week 1 - Introduction)",
      (title) => {
        const markdown = buildModule({ title });
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Module inserted");
      }
    );
    modal.open();
  }
  async insertHeader(editor) {
    const modal = new SimpleTextModal(
      this.app,
      "Insert Canvas Header",
      "Header text",
      "Enter header text",
      (title) => {
        const markdown = buildHeader({ title });
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Header inserted");
      }
    );
    modal.open();
  }
  async insertPage(editor) {
    const modal = new SimpleTextModal(
      this.app,
      "Insert Canvas Page",
      "Page title",
      "Enter page title",
      (title) => {
        const markdown = buildPage({ title });
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Page inserted");
      }
    );
    modal.open();
  }
  async insertLink(editor) {
    const modal = new TwoFieldModal(
      this.app,
      "Insert Canvas Link",
      "Link title",
      "Enter link title",
      "URL",
      "Enter URL (e.g., https://example.com)",
      (data) => {
        const markdown = buildLink({ title: data.field1, url: data.field2 });
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Link inserted");
      }
    );
    modal.open();
  }
  async insertFile(editor) {
    const modal = new TwoFieldModal(
      this.app,
      "Insert Canvas File",
      "Display title",
      "Enter display title",
      "Filename",
      "Enter filename (e.g., document.pdf)",
      (data) => {
        const markdown = buildFile({ title: data.field1, filename: data.field2 });
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("File inserted");
      }
    );
    modal.open();
  }
  async insertAssignment(editor) {
    const modal = new AssignmentModal(
      this.app,
      (data) => {
        const markdown = buildAssignment(data);
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Assignment inserted");
      }
    );
    modal.open();
  }
  async insertDiscussion(editor) {
    const modal = new DiscussionModal(
      this.app,
      (data) => {
        const markdown = buildDiscussion(data);
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Discussion inserted");
      }
    );
    modal.open();
  }
  async insertInternalLink(editor) {
    const modal = new InternalLinkModal(
      this.app,
      (data) => {
        const markdown = buildInternalLink(data);
        insertAtCursor(editor, markdown);
        new import_obsidian14.Notice("Internal link inserted");
      }
    );
    modal.open();
  }
  /**
   * Meta-command: opens type picker then delegates to appropriate insert method
   */
  async addContent(editor) {
    const modal = new ContentTypeModal(
      this.app,
      async (type) => {
        switch (type) {
          case "module":
            await this.insertModule(editor);
            break;
          case "header":
            await this.insertHeader(editor);
            break;
          case "page":
            await this.insertPage(editor);
            break;
          case "link":
            await this.insertLink(editor);
            break;
          case "file":
            await this.insertFile(editor);
            break;
          case "assignment":
            await this.insertAssignment(editor);
            break;
          case "discussion":
            await this.insertDiscussion(editor);
            break;
          case "internal-link":
            await this.insertInternalLink(editor);
            break;
        }
      }
    );
    modal.open();
  }
};
