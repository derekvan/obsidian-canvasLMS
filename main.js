/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CanvaslmsHelperPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  canvasUrl: "",
  canvasToken: ""
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Canvas LMS settings" });
    containerEl.createEl("p", {
      text: "To use this plugin, you need a Canvas API token. Generate one from your Canvas account settings > Approved Integrations > New Access Token."
    });
    new import_obsidian.Setting(containerEl).setName("Canvas URL").setDesc("The base URL of your Canvas instance (e.g., https://your-institution.instructure.com)").addText((text) => text.setPlaceholder("https://your-institution.instructure.com").setValue(this.plugin.settings.canvasUrl).onChange(async (value) => {
      this.plugin.settings.canvasUrl = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Canvas API token").setDesc("Your Canvas API access token").addText((text) => {
      text.setPlaceholder("Enter your Canvas API token").setValue(this.plugin.settings.canvasToken).onChange(async (value) => {
        this.plugin.settings.canvasToken = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
  }
};

// src/canvas/api-client.ts
var import_obsidian2 = require("obsidian");
var CanvasApiClient = class {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl.replace(/\/$/, "");
    this.token = token;
  }
  /**
   * Make a generic API request to Canvas
   */
  async request(endpoint) {
    var _a;
    const url = `${this.baseUrl}${endpoint}`;
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.token}`,
          "Accept": "application/json"
        }
      });
      if (response.status === 200) {
        return response.json;
      } else {
        throw new Error(`HTTP ${response.status}: ${response.text}`);
      }
    } catch (error) {
      if (error.status === 401) {
        throw new Error("Invalid Canvas token. Please check your settings.");
      } else if (error.status === 403) {
        throw new Error("Access denied. You may not have permission to view this course.");
      } else if (error.status === 404) {
        throw new Error("Course/resource not found. Check the course ID.");
      } else if ((_a = error.message) == null ? void 0 : _a.includes("net::")) {
        throw new Error("Cannot connect to Canvas. Check your internet connection.");
      } else {
        throw error;
      }
    }
  }
  /**
   * Get course information
   */
  async getCourse(courseId) {
    return await this.request(`/api/v1/courses/${courseId}`);
  }
  /**
   * Get all modules in a course
   */
  async getModules(courseId) {
    return await this.request(`/api/v1/courses/${courseId}/modules`);
  }
  /**
   * Get all items in a module
   */
  async getModuleItems(courseId, moduleId) {
    return await this.request(
      `/api/v1/courses/${courseId}/modules/${moduleId}/items`
    );
  }
  /**
   * Get a specific page by URL slug
   */
  async getPage(courseId, pageUrl) {
    return await this.request(
      `/api/v1/courses/${courseId}/pages/${pageUrl}`
    );
  }
  /**
   * Get a specific assignment
   */
  async getAssignment(courseId, assignmentId) {
    return await this.request(
      `/api/v1/courses/${courseId}/assignments/${assignmentId}`
    );
  }
  /**
   * Get a specific discussion topic
   */
  async getDiscussion(courseId, topicId) {
    return await this.request(
      `/api/v1/courses/${courseId}/discussion_topics/${topicId}`
    );
  }
  /**
   * Get a specific file
   */
  async getFile(fileId) {
    return await this.request(`/api/v1/files/${fileId}`);
  }
};

// node_modules/turndown/lib/turndown.browser.es.js
function extend(destination) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (source.hasOwnProperty(key)) destination[key] = source[key];
    }
  }
  return destination;
}
function repeat(character, count) {
  return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
  return string.replace(/^\n*/, "");
}
function trimTrailingNewlines(string) {
  var indexEnd = string.length;
  while (indexEnd > 0 && string[indexEnd - 1] === "\n") indexEnd--;
  return string.substring(0, indexEnd);
}
function trimNewlines(string) {
  return trimTrailingNewlines(trimLeadingNewlines(string));
}
var blockElements = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function isBlock(node) {
  return is(node, blockElements);
}
var voidElements = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function isVoid(node) {
  return is(node, voidElements);
}
function hasVoid(node) {
  return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function isMeaningfulWhenBlank(node) {
  return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
  return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
  return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
  return node.getElementsByTagName && tagNames.some(function(tagName) {
    return node.getElementsByTagName(tagName).length;
  });
}
var rules = {};
rules.paragraph = {
  filter: "p",
  replacement: function(content) {
    return "\n\n" + content + "\n\n";
  }
};
rules.lineBreak = {
  filter: "br",
  replacement: function(content, node, options) {
    return options.br + "\n";
  }
};
rules.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(content, node, options) {
    var hLevel = Number(node.nodeName.charAt(1));
    if (options.headingStyle === "setext" && hLevel < 3) {
      var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
      return "\n\n" + content + "\n" + underline + "\n\n";
    } else {
      return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
    }
  }
};
rules.blockquote = {
  filter: "blockquote",
  replacement: function(content) {
    content = trimNewlines(content).replace(/^/gm, "> ");
    return "\n\n" + content + "\n\n";
  }
};
rules.list = {
  filter: ["ul", "ol"],
  replacement: function(content, node) {
    var parent = node.parentNode;
    if (parent.nodeName === "LI" && parent.lastElementChild === node) {
      return "\n" + content;
    } else {
      return "\n\n" + content + "\n\n";
    }
  }
};
rules.listItem = {
  filter: "li",
  replacement: function(content, node, options) {
    var prefix = options.bulletListMarker + "   ";
    var parent = node.parentNode;
    if (parent.nodeName === "OL") {
      var start = parent.getAttribute("start");
      var index = Array.prototype.indexOf.call(parent.children, node);
      prefix = (start ? Number(start) + index : index + 1) + ".  ";
    }
    var isParagraph = /\n$/.test(content);
    content = trimNewlines(content) + (isParagraph ? "\n" : "");
    content = content.replace(/\n/gm, "\n" + " ".repeat(prefix.length));
    return prefix + content + (node.nextSibling ? "\n" : "");
  }
};
rules.indentedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
  }
};
rules.fencedCodeBlock = {
  filter: function(node, options) {
    return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
  },
  replacement: function(content, node, options) {
    var className = node.firstChild.getAttribute("class") || "";
    var language = (className.match(/language-(\S+)/) || [null, ""])[1];
    var code = node.firstChild.textContent;
    var fenceChar = options.fence.charAt(0);
    var fenceSize = 3;
    var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
    var match;
    while (match = fenceInCodeRegex.exec(code)) {
      if (match[0].length >= fenceSize) {
        fenceSize = match[0].length + 1;
      }
    }
    var fence = repeat(fenceChar, fenceSize);
    return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
  }
};
rules.horizontalRule = {
  filter: "hr",
  replacement: function(content, node, options) {
    return "\n\n" + options.hr + "\n\n";
  }
};
rules.inlineLink = {
  filter: function(node, options) {
    return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node) {
    var href = node.getAttribute("href");
    if (href) href = href.replace(/([()])/g, "\\$1");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
    return "[" + content + "](" + href + title + ")";
  }
};
rules.referenceLink = {
  filter: function(node, options) {
    return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
  },
  replacement: function(content, node, options) {
    var href = node.getAttribute("href");
    var title = cleanAttribute(node.getAttribute("title"));
    if (title) title = ' "' + title + '"';
    var replacement;
    var reference;
    switch (options.linkReferenceStyle) {
      case "collapsed":
        replacement = "[" + content + "][]";
        reference = "[" + content + "]: " + href + title;
        break;
      case "shortcut":
        replacement = "[" + content + "]";
        reference = "[" + content + "]: " + href + title;
        break;
      default:
        var id = this.references.length + 1;
        replacement = "[" + content + "][" + id + "]";
        reference = "[" + id + "]: " + href + title;
    }
    this.references.push(reference);
    return replacement;
  },
  references: [],
  append: function(options) {
    var references = "";
    if (this.references.length) {
      references = "\n\n" + this.references.join("\n") + "\n\n";
      this.references = [];
    }
    return references;
  }
};
rules.emphasis = {
  filter: ["em", "i"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.emDelimiter + content + options.emDelimiter;
  }
};
rules.strong = {
  filter: ["strong", "b"],
  replacement: function(content, node, options) {
    if (!content.trim()) return "";
    return options.strongDelimiter + content + options.strongDelimiter;
  }
};
rules.code = {
  filter: function(node) {
    var hasSiblings = node.previousSibling || node.nextSibling;
    var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
    return node.nodeName === "CODE" && !isCodeBlock;
  },
  replacement: function(content) {
    if (!content) return "";
    content = content.replace(/\r?\n|\r/g, " ");
    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
    var delimiter = "`";
    var matches = content.match(/`+/gm) || [];
    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + "`";
    return delimiter + extraSpace + content + extraSpace + delimiter;
  }
};
rules.image = {
  filter: "img",
  replacement: function(content, node) {
    var alt = cleanAttribute(node.getAttribute("alt"));
    var src = node.getAttribute("src") || "";
    var title = cleanAttribute(node.getAttribute("title"));
    var titlePart = title ? ' "' + title + '"' : "";
    return src ? "![" + alt + "](" + src + titlePart + ")" : "";
  }
};
function cleanAttribute(attribute) {
  return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
}
function Rules(options) {
  this.options = options;
  this._keep = [];
  this._remove = [];
  this.blankRule = {
    replacement: options.blankReplacement
  };
  this.keepReplacement = options.keepReplacement;
  this.defaultRule = {
    replacement: options.defaultReplacement
  };
  this.array = [];
  for (var key in options.rules) this.array.push(options.rules[key]);
}
Rules.prototype = {
  add: function(key, rule) {
    this.array.unshift(rule);
  },
  keep: function(filter) {
    this._keep.unshift({
      filter,
      replacement: this.keepReplacement
    });
  },
  remove: function(filter) {
    this._remove.unshift({
      filter,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(node) {
    if (node.isBlank) return this.blankRule;
    var rule;
    if (rule = findRule(this.array, node, this.options)) return rule;
    if (rule = findRule(this._keep, node, this.options)) return rule;
    if (rule = findRule(this._remove, node, this.options)) return rule;
    return this.defaultRule;
  },
  forEach: function(fn) {
    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);
  }
};
function findRule(rules2, node, options) {
  for (var i = 0; i < rules2.length; i++) {
    var rule = rules2[i];
    if (filterValue(rule, node, options)) return rule;
  }
  return void 0;
}
function filterValue(rule, node, options) {
  var filter = rule.filter;
  if (typeof filter === "string") {
    if (filter === node.nodeName.toLowerCase()) return true;
  } else if (Array.isArray(filter)) {
    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
  } else if (typeof filter === "function") {
    if (filter.call(rule, node, options)) return true;
  } else {
    throw new TypeError("`filter` needs to be a string, array, or function");
  }
}
function collapseWhitespace(options) {
  var element = options.element;
  var isBlock2 = options.isBlock;
  var isVoid2 = options.isVoid;
  var isPre = options.isPre || function(node2) {
    return node2.nodeName === "PRE";
  };
  if (!element.firstChild || isPre(element)) return;
  var prevText = null;
  var keepLeadingWs = false;
  var prev = null;
  var node = next(prev, element, isPre);
  while (node !== element) {
    if (node.nodeType === 3 || node.nodeType === 4) {
      var text = node.data.replace(/[ \r\n\t]+/g, " ");
      if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
        text = text.substr(1);
      }
      if (!text) {
        node = remove(node);
        continue;
      }
      node.data = text;
      prevText = node;
    } else if (node.nodeType === 1) {
      if (isBlock2(node) || node.nodeName === "BR") {
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
        }
        prevText = null;
        keepLeadingWs = false;
      } else if (isVoid2(node) || isPre(node)) {
        prevText = null;
        keepLeadingWs = true;
      } else if (prevText) {
        keepLeadingWs = false;
      }
    } else {
      node = remove(node);
      continue;
    }
    var nextNode = next(prev, node, isPre);
    prev = node;
    node = nextNode;
  }
  if (prevText) {
    prevText.data = prevText.data.replace(/ $/, "");
    if (!prevText.data) {
      remove(prevText);
    }
  }
}
function remove(node) {
  var next2 = node.nextSibling || node.parentNode;
  node.parentNode.removeChild(node);
  return next2;
}
function next(prev, current, isPre) {
  if (prev && prev.parentNode === current || isPre(current)) {
    return current.nextSibling || current.parentNode;
  }
  return current.firstChild || current.nextSibling || current.parentNode;
}
var root = typeof window !== "undefined" ? window : {};
function canParseHTMLNatively() {
  var Parser = root.DOMParser;
  var canParse = false;
  try {
    if (new Parser().parseFromString("", "text/html")) {
      canParse = true;
    }
  } catch (e) {
  }
  return canParse;
}
function createHTMLParser() {
  var Parser = function() {
  };
  {
    if (shouldUseActiveX()) {
      Parser.prototype.parseFromString = function(string) {
        var doc = new window.ActiveXObject("htmlfile");
        doc.designMode = "on";
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    } else {
      Parser.prototype.parseFromString = function(string) {
        var doc = document.implementation.createHTMLDocument("");
        doc.open();
        doc.write(string);
        doc.close();
        return doc;
      };
    }
  }
  return Parser;
}
function shouldUseActiveX() {
  var useActiveX = false;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch (e) {
    if (root.ActiveXObject) useActiveX = true;
  }
  return useActiveX;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
  var root2;
  if (typeof input === "string") {
    var doc = htmlParser().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + input + "</x-turndown>",
      "text/html"
    );
    root2 = doc.getElementById("turndown-root");
  } else {
    root2 = input.cloneNode(true);
  }
  collapseWhitespace({
    element: root2,
    isBlock,
    isVoid,
    isPre: options.preformattedCode ? isPreOrCode : null
  });
  return root2;
}
var _htmlParser;
function htmlParser() {
  _htmlParser = _htmlParser || new HTMLParser();
  return _htmlParser;
}
function isPreOrCode(node) {
  return node.nodeName === "PRE" || node.nodeName === "CODE";
}
function Node(node, options) {
  node.isBlock = isBlock(node);
  node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
  node.isBlank = isBlank(node);
  node.flankingWhitespace = flankingWhitespace(node, options);
  return node;
}
function isBlank(node) {
  return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
  if (node.isBlock || options.preformattedCode && node.isCode) {
    return { leading: "", trailing: "" };
  }
  var edges = edgeWhitespace(node.textContent);
  if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
    edges.leading = edges.leadingNonAscii;
  }
  if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
    edges.trailing = edges.trailingNonAscii;
  }
  return { leading: edges.leading, trailing: edges.trailing };
}
function edgeWhitespace(string) {
  var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: m[1],
    // whole string for whitespace-only strings
    leadingAscii: m[2],
    leadingNonAscii: m[3],
    trailing: m[4],
    // empty for whitespace-only strings
    trailingNonAscii: m[5],
    trailingAscii: m[6]
  };
}
function isFlankedByWhitespace(side, node, options) {
  var sibling;
  var regExp;
  var isFlanked;
  if (side === "left") {
    sibling = node.previousSibling;
    regExp = / $/;
  } else {
    sibling = node.nextSibling;
    regExp = /^ /;
  }
  if (sibling) {
    if (sibling.nodeType === 3) {
      isFlanked = regExp.test(sibling.nodeValue);
    } else if (options.preformattedCode && sibling.nodeName === "CODE") {
      isFlanked = false;
    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
      isFlanked = regExp.test(sibling.textContent);
    }
  }
  return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function TurndownService(options) {
  if (!(this instanceof TurndownService)) return new TurndownService(options);
  var defaults = {
    rules,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: false,
    blankReplacement: function(content, node) {
      return node.isBlock ? "\n\n" : "";
    },
    keepReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
    },
    defaultReplacement: function(content, node) {
      return node.isBlock ? "\n\n" + content + "\n\n" : content;
    }
  };
  this.options = extend({}, defaults, options);
  this.rules = new Rules(this.options);
}
TurndownService.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(input) {
    if (!canConvert(input)) {
      throw new TypeError(
        input + " is not a string, or an element/document/fragment node."
      );
    }
    if (input === "") return "";
    var output = process.call(this, new RootNode(input, this.options));
    return postProcess.call(this, output);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(plugin) {
    if (Array.isArray(plugin)) {
      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);
    } else if (typeof plugin === "function") {
      plugin(this);
    } else {
      throw new TypeError("plugin must be a Function or an Array of Functions");
    }
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(key, rule) {
    this.rules.add(key, rule);
    return this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(filter) {
    this.rules.keep(filter);
    return this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(filter) {
    this.rules.remove(filter);
    return this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(string) {
    return escapes.reduce(function(accumulator, escape) {
      return accumulator.replace(escape[0], escape[1]);
    }, string);
  }
};
function process(parentNode) {
  var self = this;
  return reduce.call(parentNode.childNodes, function(output, node) {
    node = new Node(node, self.options);
    var replacement = "";
    if (node.nodeType === 3) {
      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
    } else if (node.nodeType === 1) {
      replacement = replacementForNode.call(self, node);
    }
    return join(output, replacement);
  }, "");
}
function postProcess(output) {
  var self = this;
  this.rules.forEach(function(rule) {
    if (typeof rule.append === "function") {
      output = join(output, rule.append(self.options));
    }
  });
  return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function replacementForNode(node) {
  var rule = this.rules.forNode(node);
  var content = process.call(this, node);
  var whitespace = node.flankingWhitespace;
  if (whitespace.leading || whitespace.trailing) content = content.trim();
  return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
function join(output, replacement) {
  var s1 = trimTrailingNewlines(output);
  var s2 = trimLeadingNewlines(replacement);
  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
  var separator = "\n\n".substring(0, nls);
  return s1 + separator + s2;
}
function canConvert(input) {
  return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
var turndown_browser_es_default = TurndownService;

// src/utils/html-to-markdown.ts
var turndownService = new turndown_browser_es_default({
  headingStyle: "atx",
  hr: "---",
  bulletListMarker: "-",
  codeBlockStyle: "fenced",
  emDelimiter: "*"
});
turndownService.addRule("removeCanvasWrappers", {
  filter: (node) => {
    var _a, _b;
    return node.nodeName === "DIV" && ((_b = (_a = node.getAttribute("class")) == null ? void 0 : _a.includes("user_content")) != null ? _b : false);
  },
  replacement: (content) => content
});
function htmlToMarkdown(html) {
  if (!html) return "";
  try {
    return turndownService.turndown(html).trim();
  } catch (error) {
    console.error("Error converting HTML to Markdown:", error);
    return html.replace(/<[^>]+>/g, "").trim();
  }
}

// src/canvas/formatter.ts
var CanvasCourseFormatter = class {
  /**
   * Format complete course data into Markdown
   */
  formatCourse(courseId, canvasUrl, modules, itemsData) {
    let markdown = "";
    markdown += this.formatFrontmatter(courseId, canvasUrl);
    markdown += "\n";
    for (const module2 of modules) {
      markdown += this.formatModule(module2, itemsData);
    }
    return markdown;
  }
  /**
   * Format YAML frontmatter
   */
  formatFrontmatter(courseId, canvasUrl) {
    return `---
canvas_course_id: ${courseId}
canvas_url: ${canvasUrl}/courses/${courseId}
---`;
  }
  /**
   * Format a module and its items
   */
  formatModule(module2, itemsData) {
    let markdown = `
# ${module2.name}
`;
    markdown += `<!-- canvas_module_id: ${module2.id} -->
`;
    const items = itemsData.get(`module_${module2.id}`);
    if (items && items.length > 0) {
      for (const item of items) {
        markdown += this.formatModuleItem(item, itemsData);
      }
    }
    return markdown;
  }
  /**
   * Format a module item based on its type
   */
  formatModuleItem(item, itemsData) {
    switch (item.type) {
      case "SubHeader":
        return this.formatHeader(item);
      case "Page":
        return this.formatPage(item, itemsData);
      case "ExternalUrl":
        return this.formatLink(item);
      case "File":
        return this.formatFile(item, itemsData);
      case "Assignment":
        return this.formatAssignment(item, itemsData);
      case "Discussion":
        return this.formatDiscussion(item, itemsData);
      default:
        console.warn(`Unknown module item type: ${item.type}`);
        return "";
    }
  }
  /**
   * Format a header (SubHeader in Canvas)
   */
  formatHeader(item) {
    return `
## [header] ${item.title}
<!-- canvas_module_item_id: ${item.id} -->
`;
  }
  /**
   * Format a page
   */
  formatPage(item, itemsData) {
    const page = itemsData.get(`page_${item.page_url}`);
    let markdown = `
## [page] ${item.title}
`;
    if (page) {
      markdown += `<!-- canvas_page_id: ${page.url} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (page == null ? void 0 : page.body) {
      const bodyMarkdown = htmlToMarkdown(page.body);
      if (bodyMarkdown) {
        markdown += bodyMarkdown + "\n";
      }
    }
    return markdown;
  }
  /**
   * Format an external link
   */
  formatLink(item) {
    return `
## [link] ${item.title}
url: ${item.external_url || ""}
<!-- canvas_module_item_id: ${item.id} -->
`;
  }
  /**
   * Format a file
   */
  formatFile(item, itemsData) {
    const file = itemsData.get(`file_${item.content_id}`);
    let markdown = `
## [file] ${item.title}
`;
    if (file) {
      markdown += `<!-- canvas_file_id: ${file.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (file == null ? void 0 : file.filename) {
      markdown += `filename: ${file.filename}
`;
    }
    return markdown;
  }
  /**
   * Format an assignment
   */
  formatAssignment(item, itemsData) {
    const assignment = itemsData.get(`assignment_${item.content_id}`);
    let markdown = `
## [assignment] ${item.title}
`;
    if (assignment) {
      markdown += `<!-- canvas_assignment_id: ${assignment.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (assignment) {
      if (assignment.points_possible !== null && assignment.points_possible !== void 0) {
        markdown += `points: ${assignment.points_possible}
`;
      }
      if (assignment.due_at) {
        const dueDate = this.formatDate(assignment.due_at);
        markdown += `due: ${dueDate}
`;
      }
      if (assignment.grading_type) {
        markdown += `grade_display: ${assignment.grading_type}
`;
      }
      if (assignment.submission_types && assignment.submission_types.length > 0) {
        markdown += `submission_types: ${assignment.submission_types.join(", ")}
`;
      }
      if (assignment.description) {
        markdown += "\n---\n";
        const descriptionMarkdown = htmlToMarkdown(assignment.description);
        if (descriptionMarkdown) {
          markdown += descriptionMarkdown + "\n";
        }
      }
    }
    return markdown;
  }
  /**
   * Format a discussion
   */
  formatDiscussion(item, itemsData) {
    const discussion = itemsData.get(`discussion_${item.content_id}`);
    let markdown = `
## [discussion] ${item.title}
`;
    if (discussion) {
      markdown += `<!-- canvas_discussion_id: ${discussion.id} -->
`;
    }
    markdown += `<!-- canvas_module_item_id: ${item.id} -->
`;
    if (discussion) {
      markdown += `require_initial_post: ${discussion.require_initial_post}
`;
      markdown += `threaded: ${discussion.discussion_type === "threaded"}
`;
      const isGraded = discussion.assignment !== void 0;
      markdown += `graded: ${isGraded}
`;
      if (isGraded && discussion.assignment) {
        markdown += `points: ${discussion.assignment.points_possible}
`;
        if (discussion.assignment.due_at) {
          const dueDate = this.formatDate(discussion.assignment.due_at);
          markdown += `due: ${dueDate}
`;
        }
      }
      if (discussion.message) {
        markdown += "\n---\n";
        const messageMarkdown = htmlToMarkdown(discussion.message);
        if (messageMarkdown) {
          markdown += messageMarkdown + "\n";
        }
      }
    }
    return markdown;
  }
  /**
   * Format ISO date to "2026-01-20 02:00pm" format
   */
  formatDate(isoDate) {
    const date = new Date(isoDate);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    let hours = date.getHours();
    const minutes = String(date.getMinutes()).padStart(2, "0");
    const ampm = hours >= 12 ? "pm" : "am";
    hours = hours % 12 || 12;
    return `${year}-${month}-${day} ${String(hours).padStart(2, "0")}:${minutes}${ampm}`;
  }
};

// src/modals/course-input-modal.ts
var import_obsidian3 = require("obsidian");
var CourseInputModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.courseId = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Download Canvas course");
    contentEl.createEl("p", {
      text: "Enter the Canvas course ID (number from course URL)"
    });
    contentEl.createEl("p", {
      text: "Example: 126998",
      cls: "mod-muted"
    });
    const inputSetting = new import_obsidian3.Setting(contentEl).setName("Course ID").addText((text) => {
      text.setPlaceholder("Enter course ID").onChange((value) => {
        this.courseId = value.trim();
      });
      setTimeout(() => text.inputEl.focus(), 10);
      text.inputEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          this.submit();
        }
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const submitButton = buttonContainer.createEl("button", {
      text: "Download",
      cls: "mod-cta"
    });
    submitButton.addEventListener("click", () => this.submit());
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => this.close());
  }
  submit() {
    if (!this.courseId) {
      const existingError = this.contentEl.querySelector(".course-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Please enter a course ID",
        cls: "course-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    if (!/^\d+$/.test(this.courseId)) {
      const existingError = this.contentEl.querySelector(".course-input-error");
      if (existingError) {
        existingError.remove();
      }
      const errorEl = this.contentEl.createEl("p", {
        text: "Course ID must be a number",
        cls: "course-input-error"
      });
      errorEl.style.color = "var(--text-error)";
      return;
    }
    this.close();
    this.onSubmit(this.courseId);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var CanvaslmsHelperPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("Loading canvasLMS-helper");
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.addCommand({
      id: "download-course",
      name: "Download course",
      callback: async () => {
        await this.downloadCourse();
      }
    });
  }
  /**
   * Main download course workflow
   */
  async downloadCourse() {
    if (!this.settings.canvasUrl || !this.settings.canvasToken) {
      new import_obsidian4.Notice("Please configure Canvas URL and token in settings");
      return;
    }
    const courseId = await this.promptForCourseId();
    if (!courseId) return;
    const notice = new import_obsidian4.Notice("Downloading course from Canvas...", 0);
    try {
      const client = new CanvasApiClient(this.settings.canvasUrl, this.settings.canvasToken);
      const courseData = await this.fetchCourseData(client, courseId);
      const formatter = new CanvasCourseFormatter();
      const markdown = formatter.formatCourse(
        courseId,
        this.settings.canvasUrl,
        courseData.modules,
        courseData.itemsData
      );
      await this.saveCourseFile(courseId, courseData.course.name, markdown);
      notice.hide();
      new import_obsidian4.Notice("Course downloaded successfully!");
    } catch (error) {
      notice.hide();
      new import_obsidian4.Notice(`Error: ${error.message}`);
      console.error("Canvas download error:", error);
    }
  }
  /**
   * Prompt user for course ID via modal
   */
  async promptForCourseId() {
    return new Promise((resolve) => {
      const modal = new CourseInputModal(this.app, (courseId) => {
        resolve(courseId);
      });
      modal.open();
    });
  }
  /**
   * Fetch all course data from Canvas
   */
  async fetchCourseData(client, courseId) {
    const course = await client.getCourse(courseId);
    const modules = await client.getModules(courseId);
    const itemsData = /* @__PURE__ */ new Map();
    for (const module2 of modules) {
      const items = await client.getModuleItems(courseId, module2.id.toString());
      itemsData.set(`module_${module2.id}`, items);
      for (const item of items) {
        await this.fetchItemDetails(client, courseId, item, itemsData);
      }
    }
    return { course, modules, itemsData };
  }
  /**
   * Fetch detailed content for a module item based on its type
   */
  async fetchItemDetails(client, courseId, item, itemsData) {
    try {
      switch (item.type) {
        case "Page":
          if (item.page_url) {
            const page = await client.getPage(courseId, item.page_url);
            itemsData.set(`page_${item.page_url}`, page);
          }
          break;
        case "Assignment":
          if (item.content_id) {
            const assignment = await client.getAssignment(courseId, item.content_id.toString());
            itemsData.set(`assignment_${item.content_id}`, assignment);
          }
          break;
        case "Discussion":
          if (item.content_id) {
            const discussion = await client.getDiscussion(courseId, item.content_id.toString());
            itemsData.set(`discussion_${item.content_id}`, discussion);
          }
          break;
        case "File":
          if (item.content_id) {
            const file = await client.getFile(item.content_id.toString());
            itemsData.set(`file_${item.content_id}`, file);
          }
          break;
      }
    } catch (error) {
      console.warn(`Failed to fetch details for ${item.type} "${item.title}":`, error);
    }
  }
  /**
   * Save course markdown to vault
   */
  async saveCourseFile(courseId, courseName, markdown) {
    const safeName = courseName.replace(/[^a-zA-Z0-9-_ ]/g, "").trim();
    const filename = `Canvas Course ${courseId} - ${safeName}.md`;
    const normalizedPath = (0, import_obsidian4.normalizePath)(filename);
    const existingFile = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (existingFile instanceof import_obsidian4.TFile) {
      await this.app.vault.modify(existingFile, markdown);
    } else {
      await this.app.vault.create(normalizedPath, markdown);
    }
    const file = this.app.vault.getAbstractFileByPath(normalizedPath);
    if (file instanceof import_obsidian4.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    }
  }
  async onunload() {
    console.log("Unloading canvasLMS-helper");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
